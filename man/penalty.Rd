% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/penalty.R
\name{penalty}
\alias{penalty}
\alias{penalty.default}
\alias{penalty.gam}
\alias{penalty.mgcv.smooth}
\alias{penalty.tensor.smooth}
\alias{penalty.t2.smooth}
\alias{penalty.re.smooth.spec}
\title{Extract and tidy penalty matrices}
\usage{
penalty(object, ...)

\method{penalty}{default}(object, rescale = FALSE, data, knots = NULL, constraints = FALSE, ...)

\method{penalty}{gam}(
  object,
  select = NULL,
  smooth = deprecated(),
  rescale = FALSE,
  partial_match = FALSE,
  ...
)

\method{penalty}{mgcv.smooth}(object, rescale = FALSE, ...)

\method{penalty}{tensor.smooth}(object, margins = FALSE, ...)

\method{penalty}{t2.smooth}(object, margins = FALSE, ...)

\method{penalty}{re.smooth.spec}(object, data, ...)
}
\arguments{
\item{object}{a fitted GAM or a smooth.}

\item{...}{additional arguments passed to methods.}

\item{rescale}{logical; by default, \emph{mgcv} will scale the penalty matrix for
better performance in \code{\link[mgcv:gamm]{mgcv::gamm()}}. If \code{rescale} is \code{TRUE}, this scaling
will be undone to put the penalty matrix back on the original scale.}

\item{data}{data frame; a data frame of values for terms mentioned in the
smooth specification.}

\item{knots}{a list or data frame with named components containing
knots locations. Names must match the covariates for which the basis
is required. See \code{\link[mgcv:smoothCon]{mgcv::smoothCon()}}.}

\item{constraints}{logical; should identifiability constraints be applied to
the smooth basis. See argument \code{absorb.cons} in \code{\link[mgcv:smoothCon]{mgcv::smoothCon()}}.}

\item{select}{character, logical, or numeric; which smooths to extract
penalties for. If \code{NULL}, the default, then penalties for all model
smooths are drawn. Numeric \code{select} indexes the smooths in the order they
are specified in the formula and stored in \code{object}. Character \code{select}
matches the labels for smooths as shown for example in the output from
\code{summary(object)}. Logical \code{select} operates as per numeric \code{select} in
the order that smooths are stored.}

\item{smooth}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}} Use \code{select} instead.}

\item{partial_match}{logical; should smooths be selected by partial matches
with \code{select}? If \code{TRUE}, \code{select} can only be a single string to match
against.}

\item{margins}{logical; extract the penalty matrices for the tensor
product or the marginal smooths of the tensor product?}
}
\value{
A 'tibble' (data frame) of class \code{penalty_df} inheriting from
\code{tbl_df}, with the following components:
\itemize{
\item \code{.smooth} - character; the label \emph{mgcv} uses to refer to the smooth,
\item \code{.type} - character; the type of smooth,
\item \code{.penalty} - character; the label for the specific penalty. Some smooths
have multiple penalty matrices, so the \code{penalty} component identifies the
particular penalty matrix and uses the labelling that \emph{mgcv} uses
internally,
\item \code{.row} - character; a label of the form \code{fn} where \code{n} is an integer for
the \code{n}th basis function, referencing the columns of the penalty matrix,
\item \code{.col} - character; a label of the form \code{fn} where \code{n} is an integer for
the \code{n}th basis function, referencing the columns of the penalty matrix,
\item \code{.value} - double; the value of the penalty matrix for the combination of
\code{row} and \code{col},
}
}
\description{
Extract and tidy penalty matrices
}
\note{
The \code{print()} method uses \code{\link[base:zapsmall]{base::zapsmall()}} to turn very small numbers
into 0s for display purposes only; the underlying values of the penalty
matrix or matrices are not changed.

For smooths that are subject to an eigendecomposition (e.g. the default
thin plate regression splines, \code{bs = "tp"}), the signs of the eigenvectors
are not defined and as such you can expect differences across systems in
the penalties for such smooths that are system-, OS-, and CPU architecture-
specific.
}
\examples{
\dontshow{
op <- options(cli.unicode = FALSE, pillar.sigfig = 3)
}
load_mgcv()
dat <- data_sim("eg4", n = 400, seed = 42)
m <- gam(
  y ~ s(x0, bs = "cr") + s(x1, bs = "cr") +
    s(x2, by = fac, bs = "cr"),
  data = dat, method = "REML"
)

# penalties for all smooths
penalty(m)

# for a specific smooth
penalty(m, select = "s(x2):fac1")

\dontshow{
options(op)
}
}
\author{
Gavin L. Simpson
}
