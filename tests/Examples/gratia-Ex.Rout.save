
R version 4.2.2 Patched (2022-11-10 r83330) -- "Innocent and Trusting"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "gratia"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('gratia')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("add_fitted.gam")
> ### * add_fitted.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_fitted.gam
> ### Title: Add fitted values from a GAM to a data frame
> ### Aliases: add_fitted.gam
> 
> ### ** Examples
> 
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", seed = 1)
> df <- df[, c("y","x0","x1","x2","x3")]
> m <-  gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> ##
> add_fitted(df, m)
# A tibble: 400 x 6
         y     x0     x1     x2    x3 .value
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>  <dbl>
 1  3.34   0.266  0.659  0.859  0.367   5.90
 2 -0.0758 0.372  0.185  0.0344 0.741   3.15
 3 10.7    0.573  0.954  0.971  0.934   8.28
 4  8.73   0.908  0.898  0.745  0.673   8.65
 5 15.0    0.202  0.944  0.273  0.701  15.7 
 6  7.67   0.898  0.724  0.677  0.848   8.38
 7  7.58   0.945  0.370  0.348  0.706   7.84
 8  8.51   0.661  0.781  0.947  0.859   6.74
 9 10.6    0.629  0.0111 0.339  0.446   9.14
10  3.72   0.0618 0.940  0.0317 0.677   7.04
# ... with 390 more rows
> 
> ## with type = "terms" or "iterms"
> add_fitted(df, m, type = "terms")
# A tibble: 400 x 10
         y     x0     x1     x2    x3 .constant `.s(x0)` .s(x1~1 .s(x2~2 .s(x3~3
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>     <dbl>    <dbl>   <dbl>   <dbl>   <dbl>
 1  3.34   0.266  0.659  0.859  0.367      7.94   0.175    0.559  -2.81   0.0351
 2 -0.0758 0.372  0.185  0.0344 0.741      7.94   0.435   -1.92   -3.23  -0.0687
 3 10.7    0.573  0.954  0.971  0.934      7.94   0.593    3.35   -3.47  -0.122 
 4  8.73   0.908  0.898  0.745  0.673      7.94  -0.812    2.77   -1.19  -0.0498
 5 15.0    0.202  0.944  0.273  0.701      7.94  -0.0589   3.23    4.63  -0.0576
 6  7.67   0.898  0.724  0.677  0.848      7.94  -0.745    1.15    0.146 -0.0981
 7  7.58   0.945  0.370  0.348  0.706      7.94  -1.07    -1.31    2.34  -0.0589
 8  8.51   0.661  0.781  0.947  0.859      7.94   0.434    1.67   -3.20  -0.101 
 9 10.6    0.629  0.0111 0.339  0.446      7.94   0.512   -1.95    2.63   0.0132
10  3.72   0.0618 0.940  0.0317 0.677      7.94  -0.695    3.20   -3.35  -0.0508
# ... with 390 more rows, and abbreviated variable names 1: `.s(x1)`,
#   2: `.s(x2)`, 3: `.s(x3)`
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("add_partial_residuals")
> ### * add_partial_residuals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_partial_residuals
> ### Title: Add partial residuals
> ### Aliases: add_partial_residuals add_partial_residuals.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", seed = 1)
> df <- df[, c("y","x0","x1","x2","x3")]
> m <-  gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = 'REML')
> 
> ## add partial residuals
> add_partial_residuals(df, m)
# A tibble: 400 x 9
         y     x0     x1     x2    x3 `s(x0)` `s(x1)` `s(x2)` `s(x3)`
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>
 1  3.34   0.266  0.659  0.859  0.367  -2.38   -2.00   -5.36  -2.52  
 2 -0.0758 0.372  0.185  0.0344 0.741  -2.79   -5.15   -6.45  -3.29  
 3 10.7    0.573  0.954  0.971  0.934   2.99    5.75   -1.07   2.28  
 4  8.73   0.908  0.898  0.745  0.673  -0.734   2.84   -1.11   0.0287
 5 15.0    0.202  0.944  0.273  0.701  -0.752   2.54    3.94  -0.750 
 6  7.67   0.898  0.724  0.677  0.848  -1.46    0.432  -0.567 -0.812 
 7  7.58   0.945  0.370  0.348  0.706  -1.33   -1.57    2.08  -0.318 
 8  8.51   0.661  0.781  0.947  0.859   2.21    3.44   -1.42   1.68  
 9 10.6    0.629  0.0111 0.339  0.446   2.01   -0.445   4.13   1.51  
10  3.72   0.0618 0.940  0.0317 0.677  -4.02   -0.123  -6.67  -3.37  
# ... with 390 more rows
> 
> ## add partial residuals for selected smooths
> add_partial_residuals(df, m, select = "s(x0)")
# A tibble: 400 x 6
         y     x0     x1     x2    x3 `s(x0)`
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>   <dbl>
 1  3.34   0.266  0.659  0.859  0.367  -2.38 
 2 -0.0758 0.372  0.185  0.0344 0.741  -2.79 
 3 10.7    0.573  0.954  0.971  0.934   2.99 
 4  8.73   0.908  0.898  0.745  0.673  -0.734
 5 15.0    0.202  0.944  0.273  0.701  -0.752
 6  7.67   0.898  0.724  0.677  0.848  -1.46 
 7  7.58   0.945  0.370  0.348  0.706  -1.33 
 8  8.51   0.661  0.781  0.947  0.859   2.21 
 9 10.6    0.629  0.0111 0.339  0.446   2.01 
10  3.72   0.0618 0.940  0.0317 0.677  -4.02 
# ... with 390 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("add_residuals.gam")
> ### * add_residuals.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_residuals.gam
> ### Title: Add residuals from a GAM to a data frame
> ### Aliases: add_residuals.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> set.seed(1)
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", seed = 1)
> df <- df[, c("y","x0","x1","x2","x3")]
> m <-  gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = 'REML')
> 
> ##
> add_residuals(df, m)
# A tibble: 400 x 6
         y     x0     x1     x2    x3 .residual
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>     <dbl>
 1  3.34   0.266  0.659  0.859  0.367   -2.56  
 2 -0.0758 0.372  0.185  0.0344 0.741   -3.22  
 3 10.7    0.573  0.954  0.971  0.934    2.40  
 4  8.73   0.908  0.898  0.745  0.673    0.0785
 5 15.0    0.202  0.944  0.273  0.701   -0.693 
 6  7.67   0.898  0.724  0.677  0.848   -0.714 
 7  7.58   0.945  0.370  0.348  0.706   -0.259 
 8  8.51   0.661  0.781  0.947  0.859    1.78  
 9 10.6    0.629  0.0111 0.339  0.446    1.50  
10  3.72   0.0618 0.940  0.0317 0.677   -3.32  
# ... with 390 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("appraise")
> ### * appraise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: appraise
> ### Title: Model diagnostic plots
> ### Aliases: appraise appraise.gam appraise.lm
> 
> ### ** Examples
> 
> load_mgcv()
> ## simulate some data...
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat)
> ## run some basic model checks
> appraise(mod, point_col = "steelblue", point_alpha = 0.4)
> 
> ## To change the theme for all panels use the & operator, for example to
> ## change the ggplot theme for all panels
> library("ggplot2")
> appraise(mod, point_col = "steelblue", point_alpha = 0.4,
+          line_col = "black") & theme_minimal()
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:mgcv’

> nameEx("basis")
> ### * basis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: basis
> ### Title: Basis expansions for smooths
> ### Aliases: basis basis.gam basis.scam basis.gamm basis.list basis.default
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg4", n = 400, seed = 42)
> 
> bf <- basis(s(x0), data = df)
> bf <- basis(s(x2, by = fac, bs = "bs"), data = df, constraints = TRUE)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("compare_smooths")
> ### * compare_smooths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compare_smooths
> ### Title: Compare smooths across models
> ### Aliases: compare_smooths
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 5)
> ## End(Don't show)
> load_mgcv()
> dat <- data_sim("eg1", seed = 2)
> 
> ## models to compare smooths across - artificially create differences
> m1 <- gam(y ~ s(x0, k = 5) + s(x1, k = 5) + s(x2, k = 5) + s(x3, k = 5),
+           data = dat, method = "REML")
> m2 <- gam(y ~ s(x0, bs = 'ts') + s(x1, bs = 'ts') + s(x2, bs = 'ts') +
+           s(x3, bs = 'ts'), data = dat, method = "REML")
> 
> ## build comparisons
> comp <- compare_smooths(m1, m2)
> comp
# A tibble: 8 x 5
  model smooth type          by    data              
  <chr> <chr>  <chr>         <chr> <list>            
1 m1    s(x0)  TPRS          <NA>  <tibble [100 x 3]>
2 m2    s(x0)  TPRS (shrink) <NA>  <tibble [100 x 3]>
3 m1    s(x1)  TPRS          <NA>  <tibble [100 x 3]>
4 m2    s(x1)  TPRS (shrink) <NA>  <tibble [100 x 3]>
5 m1    s(x2)  TPRS          <NA>  <tibble [100 x 3]>
6 m2    s(x2)  TPRS (shrink) <NA>  <tibble [100 x 3]>
7 m1    s(x3)  TPRS          <NA>  <tibble [100 x 3]>
8 m2    s(x3)  TPRS (shrink) <NA>  <tibble [100 x 3]>
> ## notice that the result is a nested tibble
> 
> draw(comp)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("confint.fderiv")
> ### * confint.fderiv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.fderiv
> ### Title: Point-wise and simultaneous confidence intervals for derivatives
> ###   of smooths
> ### Aliases: confint.fderiv
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 2, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> # new data to evaluate the derivatives at, say over the middle 50% of range
> # of each covariate
> middle <- function(x, n = 25, coverage = 0.5) {
+   v <- (1 - coverage) / 2
+   q <- quantile(x, prob = c(0 + v, 1 - v), type = 8)
+   seq(q[1], q[2], length = n)
+ }
> new_data <- sapply(dat[c("x0", "x1", "x2", "x3")], middle)
> new_data <- data.frame(new_data)
> ## first derivatives of all smooths...
> fd <- fderiv(mod, newdata = new_data)
Warning: `fderiv()` was deprecated in gratia 0.7.0.
i Please use `derivatives()` instead.
> 
> ## point-wise interval
> ci <- confint(fd, type = "confidence")
> ci
# A tibble: 100 x 4
   term    lower   est upper
   <chr>   <dbl> <dbl> <dbl>
 1 s(x0)  1.7     4.1    6.6
 2 s(x0)  1.3     3.8    6.3
 3 s(x0)  0.99    3.5    6.0
 4 s(x0)  0.68    3.1    5.6
 5 s(x0)  0.37    2.8    5.2
 6 s(x0)  0.0049  2.4    4.8
 7 s(x0) -0.40    2.0    4.5
 8 s(x0) -0.79    1.7    4.2
 9 s(x0) -1.1     1.3    3.8
10 s(x0) -1.4     0.99   3.4
# ... with 90 more rows
> 
> ## simultaneous interval for smooth term of x2
> ## Don't show: 
> set.seed(42)
> ## End(Don't show)
> x2_sint <- confint(fd, parm = "x2", type = "simultaneous",
+                    nsim = 10000, ncores = 2)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("confint.gam")
> ### * confint.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.gam
> ### Title: Point-wise and simultaneous confidence intervals for smooths
> ### Aliases: confint.gam confint.gamm confint.list
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 2, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> # new data to evaluate the smooths at, say over the middle 50% of range
> # of each covariate
> middle <- function(x, n = 50, coverage = 0.5) {
+   v <- (1 - coverage) / 2
+   q <- quantile(x, prob = c(0 + v, 1 - v), type = 8)
+   seq(q[1], q[2], length = n)
+ }
> new_data <- sapply(dat[c("x0", "x1", "x2", "x3")], middle)
> new_data <- data.frame(new_data)
> 
> ## point-wise interval for smooth of x2
> ci <- confint(mod, parm = "s(x2)", type = "confidence", data = new_data)
> ci
# A tibble: 50 x 9
   smooth type  by       x2   est    se  crit lower upper
   <chr>  <chr> <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1 s(x2)  TPRS  <NA>   0.26   5.3  0.18   2.0   5.0   5.7
 2 s(x2)  TPRS  <NA>   0.27   5.1  0.18   2.0   4.8   5.5
 3 s(x2)  TPRS  <NA>   0.28   4.9  0.18   2.0   4.6   5.3
 4 s(x2)  TPRS  <NA>   0.29   4.6  0.18   2.0   4.3   5.0
 5 s(x2)  TPRS  <NA>   0.30   4.3  0.19   2.0   3.9   4.7
 6 s(x2)  TPRS  <NA>   0.32   4.0  0.19   2.0   3.6   4.3
 7 s(x2)  TPRS  <NA>   0.33   3.6  0.20   2.0   3.2   4.0
 8 s(x2)  TPRS  <NA>   0.34   3.2  0.20   2.0   2.9   3.6
 9 s(x2)  TPRS  <NA>   0.35   2.9  0.20   2.0   2.5   3.3
10 s(x2)  TPRS  <NA>   0.36   2.5  0.19   2.0   2.1   2.9
# ... with 40 more rows
> 
> ## simultaneous interval for smooth of x2
> ## Don't show: 
> set.seed(42)
> ## End(Don't show)
> si <- confint(mod, parm = "s(x2)", data = new_data,
+               type = "simultaneous", nsim = 3000, ncores = 2)
> si
# A tibble: 50 x 9
   smooth type  by       x2   est    se  crit lower upper
   <chr>  <chr> <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>
 1 s(x2)  TPRS  <NA>   0.26   5.3  0.18   2.6   4.8   5.8
 2 s(x2)  TPRS  <NA>   0.27   5.1  0.18   2.6   4.7   5.6
 3 s(x2)  TPRS  <NA>   0.28   4.9  0.18   2.6   4.4   5.4
 4 s(x2)  TPRS  <NA>   0.29   4.6  0.18   2.6   4.1   5.1
 5 s(x2)  TPRS  <NA>   0.30   4.3  0.19   2.6   3.8   4.8
 6 s(x2)  TPRS  <NA>   0.32   4.0  0.19   2.6   3.5   4.5
 7 s(x2)  TPRS  <NA>   0.33   3.6  0.20   2.6   3.1   4.1
 8 s(x2)  TPRS  <NA>   0.34   3.2  0.20   2.6   2.7   3.8
 9 s(x2)  TPRS  <NA>   0.35   2.9  0.20   2.6   2.4   3.4
10 s(x2)  TPRS  <NA>   0.36   2.5  0.19   2.6   2.0   3.0
# ... with 40 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("data_sim")
> ### * data_sim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data_sim
> ### Title: Simulate example data for fitting GAMs
> ### Aliases: data_sim
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(pillar.sigfig = 5, cli.unicode = FALSE)
> ## End(Don't show)
> data_sim("eg1", n = 100, seed = 1)
# A tibble: 100 x 10
         y       x0      x1      x2       x3       f      f0     f1     f2    f3
     <dbl>    <dbl>   <dbl>   <dbl>    <dbl>   <dbl>   <dbl>  <dbl>  <dbl> <dbl>
 1 14.532  0.26551  0.65472 0.26751 0.67371  13.713  1.4814  3.7041 8.5277     0
 2 16.113  0.37212  0.35320 0.21865 0.094858 12.735  1.8408  2.0267 8.8680     0
 3  9.5835 0.57285  0.27026 0.51680 0.49260   6.4103 1.9478  1.7169 2.7456     0
 4 15.687  0.90821  0.99268 0.26895 0.46155  16.349  0.56879 7.2817 8.4980     0
 5  8.2216 0.20168  0.63349 0.18117 0.37522  12.792  1.1841  3.5501 8.0578     0
 6  9.9034 0.89839  0.21321 0.51858 0.99110   4.9081 0.62765 1.5318 2.7487     0
 7  5.9362 0.94468  0.12937 0.56278 0.17635   4.6020 0.34587 1.2953 2.9609     0
 8 10.839  0.66080  0.47812 0.12916 0.81344   9.7565 1.7502  2.6019 5.4045     0
 9 16.883  0.62911  0.92407 0.25637 0.068447 16.909  1.8377  6.3481 8.7237     0
10  7.3603 0.061786 0.59876 0.71794 0.40045   6.3401 0.38578 3.3119 2.6424     0
# ... with 90 more rows
> 
> # an ordered categorical response
> data_sim("eg1", n = 100, dist = "ocat", n_cat = 4, cuts = c(-1, 0, 5))
# A tibble: 100 x 11
       y       x0      x1      x2       x3        f      f0     f1     f2    f3
   <int>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl>   <dbl>  <dbl>  <dbl> <dbl>
 1     4 0.26551  0.65472 0.26751 0.67371   4.9408  1.4814  3.7041 8.5277     0
 2     4 0.37212  0.35320 0.21865 0.094858  3.9631  1.8408  2.0267 8.8680     0
 3     1 0.57285  0.27026 0.51680 0.49260  -2.3620  1.9478  1.7169 2.7456     0
 4     4 0.90821  0.99268 0.26895 0.46155   7.5762  0.56879 7.2817 8.4980     0
 5     4 0.20168  0.63349 0.18117 0.37522   4.0197  1.1841  3.5501 8.0578     0
 6     2 0.89839  0.21321 0.51858 0.99110  -3.8642  0.62765 1.5318 2.7487     0
 7     1 0.94468  0.12937 0.56278 0.17635  -4.1703  0.34587 1.2953 2.9609     0
 8     3 0.66080  0.47812 0.12916 0.81344   0.98419 1.7502  2.6019 5.4045     0
 9     4 0.62911  0.92407 0.25637 0.068447  8.1371  1.8377  6.3481 8.7237     0
10     1 0.061786 0.59876 0.71794 0.40045  -2.4322  0.38578 3.3119 2.6424     0
# ... with 90 more rows, and 1 more variable: latent <dbl>
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("data_slice")
> ### * data_slice
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data_slice
> ### Title: Prepare a data slice through model covariates
> ### Aliases: data_slice data_slice.default data_slice.gam data_slice.gamm
> ###   data_slice.list
> 
> ### ** Examples
> 
> load_mgcv()
> 
> # simulate some Gaussian data
> df <- data_sim("eg1", n = 50, seed = 2)
> 
> # fit a GAM with 1 smooth and 1 linear term
> m1 <- gam(y ~ s(x2, k = 7) + x1, data = df, method = "REML")
> 
> # Want to predict over f(x2) while holding `x1` at some value.
> # Default will use the observation closest to the median for unspecified
> # variables.
> ds <- data_slice(m1, x2 = evenly(x2, n = 50))
> 
> # for full control, specify the values you want
> ds <- data_slice(m1, x2 = evenly(x2, n = 50), x1 = 0.3)
> 
> # or provide an expression (function call) which will be evaluated in the
> # data frame passed to `data` or `model.frame(object)`
> ds <- data_slice(m1, x2 = evenly(x2, n = 50), x1 = mean(x1))
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("derivatives")
> ### * derivatives
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: derivatives
> ### Title: Derivatives of estimated smooths via finite differences
> ### Aliases: derivatives derivatives.default derivatives.gamm
> ###   derivatives.gam
> 
> ### ** Examples
> 
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 42)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> ## first derivatives of all smooths using central finite differences
> derivatives(mod, type = "central")
# A tibble: 800 x 10
   smooth var   by_var fs_var     data derivative    se  crit lower upper
   <chr>  <chr> <chr>  <chr>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>
 1 s(x0)  x0    <NA>   <NA>   0.000239       7.41  3.33  1.96 0.874  13.9
 2 s(x0)  x0    <NA>   <NA>   0.00525        7.41  3.33  1.96 0.875  13.9
 3 s(x0)  x0    <NA>   <NA>   0.0103         7.40  3.33  1.96 0.884  13.9
 4 s(x0)  x0    <NA>   <NA>   0.0153         7.40  3.31  1.96 0.902  13.9
 5 s(x0)  x0    <NA>   <NA>   0.0203         7.39  3.30  1.96 0.929  13.8
 6 s(x0)  x0    <NA>   <NA>   0.0253         7.38  3.27  1.96 0.965  13.8
 7 s(x0)  x0    <NA>   <NA>   0.0303         7.36  3.24  1.96 1.01   13.7
 8 s(x0)  x0    <NA>   <NA>   0.0353         7.34  3.20  1.96 1.07   13.6
 9 s(x0)  x0    <NA>   <NA>   0.0403         7.32  3.15  1.96 1.14   13.5
10 s(x0)  x0    <NA>   <NA>   0.0453         7.29  3.10  1.96 1.21   13.4
# ... with 790 more rows
> 
> ## derivatives for a selected smooth
> derivatives(mod, type = "central", term = "s(x1)")
# A tibble: 200 x 10
   smooth var   by_var fs_var     data derivative    se  crit lower upper
   <chr>  <chr> <chr>  <chr>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>
 1 s(x1)  x1    <NA>   <NA>   0.000405     -0.907  3.12  1.96 -7.02  5.20
 2 s(x1)  x1    <NA>   <NA>   0.00541      -0.907  3.12  1.96 -7.02  5.20
 3 s(x1)  x1    <NA>   <NA>   0.0104       -0.906  3.11  1.96 -7.01  5.20
 4 s(x1)  x1    <NA>   <NA>   0.0154       -0.903  3.11  1.96 -6.99  5.19
 5 s(x1)  x1    <NA>   <NA>   0.0204       -0.898  3.10  1.96 -6.97  5.17
 6 s(x1)  x1    <NA>   <NA>   0.0254       -0.891  3.08  1.96 -6.93  5.15
 7 s(x1)  x1    <NA>   <NA>   0.0304       -0.880  3.06  1.96 -6.88  5.12
 8 s(x1)  x1    <NA>   <NA>   0.0354       -0.867  3.04  1.96 -6.82  5.08
 9 s(x1)  x1    <NA>   <NA>   0.0404       -0.850  3.00  1.96 -6.74  5.04
10 s(x1)  x1    <NA>   <NA>   0.0454       -0.829  2.96  1.96 -6.64  4.98
# ... with 190 more rows
> ## or via a partial match
> derivatives(mod, type = "central", term = "x1", partial_match = TRUE)
# A tibble: 200 x 10
   smooth var   by_var fs_var     data derivative    se  crit lower upper
   <chr>  <chr> <chr>  <chr>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>
 1 s(x1)  x1    <NA>   <NA>   0.000405     -0.907  3.12  1.96 -7.02  5.20
 2 s(x1)  x1    <NA>   <NA>   0.00541      -0.907  3.12  1.96 -7.02  5.20
 3 s(x1)  x1    <NA>   <NA>   0.0104       -0.906  3.11  1.96 -7.01  5.20
 4 s(x1)  x1    <NA>   <NA>   0.0154       -0.903  3.11  1.96 -6.99  5.19
 5 s(x1)  x1    <NA>   <NA>   0.0204       -0.898  3.10  1.96 -6.97  5.17
 6 s(x1)  x1    <NA>   <NA>   0.0254       -0.891  3.08  1.96 -6.93  5.15
 7 s(x1)  x1    <NA>   <NA>   0.0304       -0.880  3.06  1.96 -6.88  5.12
 8 s(x1)  x1    <NA>   <NA>   0.0354       -0.867  3.04  1.96 -6.82  5.08
 9 s(x1)  x1    <NA>   <NA>   0.0404       -0.850  3.00  1.96 -6.74  5.04
10 s(x1)  x1    <NA>   <NA>   0.0454       -0.829  2.96  1.96 -6.64  4.98
# ... with 190 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("difference_smooths")
> ### * difference_smooths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: difference_smooths
> ### Title: Differences of factor smooth interactions
> ### Aliases: difference_smooths difference_smooths.gam
> 
> ### ** Examples
> 
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg4", seed = 42)
> m <- gam(y ~ fac + s(x2, by = fac) + s(x0), data = df, method = "REML")
> 
> sm_dif <- difference_smooths(m, smooth = "s(x2)")
> sm_dif
# A tibble: 300 x 9
   smooth by    level_1 level_2  diff    se    lower upper      x2
   <chr>  <chr> <chr>   <chr>   <dbl> <dbl>    <dbl> <dbl>   <dbl>
 1 s(x2)  fac   1       2       0.386 0.618 -0.824    1.60 0.00359
 2 s(x2)  fac   1       2       0.479 0.574 -0.646    1.60 0.0136 
 3 s(x2)  fac   1       2       0.572 0.534 -0.474    1.62 0.0237 
 4 s(x2)  fac   1       2       0.665 0.497 -0.308    1.64 0.0338 
 5 s(x2)  fac   1       2       0.758 0.464 -0.151    1.67 0.0438 
 6 s(x2)  fac   1       2       0.850 0.435 -0.00342  1.70 0.0539 
 7 s(x2)  fac   1       2       0.941 0.412  0.134    1.75 0.0639 
 8 s(x2)  fac   1       2       1.03  0.393  0.262    1.80 0.0740 
 9 s(x2)  fac   1       2       1.12  0.378  0.380    1.86 0.0841 
10 s(x2)  fac   1       2       1.21  0.367  0.489    1.93 0.0941 
# ... with 290 more rows
> 
> draw(sm_dif)
> 
> # include the groups means for `fac` in the difference
> sm_dif2 <- difference_smooths(m, smooth = "s(x2)", group_means = TRUE)
> draw(sm_dif2)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.basis")
> ### * draw.basis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.basis
> ### Title: Plot basis functions
> ### Aliases: draw.basis
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", n = 400, seed = 42)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> bf <- basis(m)
> draw(bf)
> 
> bf <- basis(m, "s(x2)")
> draw(bf)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.derivatives")
> ### * draw.derivatives
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.derivatives
> ### Title: Plot derivatives of smooths
> ### Aliases: draw.derivatives draw.partial_derivatives
> 
> ### ** Examples
> 
> 
> load_mgcv()
> dat <- data_sim("eg1", n = 800, dist = "normal", scale = 2, seed = 42)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> ## first derivative of all smooths
> df <- derivatives(mod, type = "central")
> draw(df)
> ## fixed axis scales
> draw(df, scales = "fixed")
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.difference_smooth")
> ### * draw.difference_smooth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.difference_smooth
> ### Title: Plot differences of smooths
> ### Aliases: draw.difference_smooth
> 
> ### ** Examples
> 
> 
> load_mgcv()
> # simulate some data; a factor smooth example
> df <- data_sim("eg4", seed = 42)
> # fit GAM
> m <- gam(y ~ fac + s(x2, by = fac) + s(x0), data = df, method = "REML")
> 
> # calculate the differences between pairs of smooths the f_j(x2) term
> diffs <- difference_smooths(m, smooth = "s(x2)")
> draw(diffs)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.evaluated_smooth")
> ### * draw.evaluated_smooth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.evaluated_smooth
> ### Title: Plot estimated smooths
> ### Aliases: draw.evaluated_smooth draw.evaluated_1d_smooth
> ###   draw.evaluated_2d_smooth geom_rug draw.evaluated_re_smooth
> ###   draw.evaluated_fs_smooth draw.evaluated_parametric_term
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(cli.unicode = FALSE)
> ## End(Don't show)
> load_mgcv()
> 
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> sm <- evaluate_smooth(m1, "s(x2)")
Warning: `evaluate_smooth()` was deprecated in gratia 0.7.0.
i Please use `smooth_estimates()` instead.
> draw(sm)
> 
> ## supply constant to shift y axis scale
> draw(sm, constant = coef(m1)[1])
> 
> dat <- data_sim("eg2", n = 1000, dist = "normal", scale = 1, seed = 2)
> m2 <- gam(y ~ s(x, z, k = 40), data = dat, method = "REML")
> 
> sm <- evaluate_smooth(m2, "s(x,z)", n = 100)
> draw(sm)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.gam")
> ### * draw.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.gam
> ### Title: Plot estimated smooths from a fitted GAM
> ### Aliases: draw.gam
> 
> ### ** Examples
> 
> load_mgcv()
> 
> # simulate some data
> df1 <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> # fit GAM
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df1, method = "REML")
> 
> # plot all smooths
> draw(m1)
> 
> # can add partial residuals
> draw(m1, residuals = TRUE)
> 
> df2 <- data_sim(2, n = 1000, dist = "normal", scale = 1, seed = 2)
> m2 <- gam(y ~ s(x, z, k = 40), data = df2, method = "REML")
> draw(m2, contour = FALSE, n = 50)
> 
> # change the number of contours drawn and the fill scale used for
> # the surface
> library("ggplot2")
> draw(m2, n_contour = 5, n = 50,
+      continuous_fill = scale_fill_distiller(palette = "Spectral",
+                                             type = "div"))
> 
> # See https://gavinsimpson.github.io/gratia/articles/custom-plotting.html
> # for more examples and for details on how to modify the theme of all the
> # plots produced by draw()
> # to modify all panels, for example to change the theme, use the & operator
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:mgcv’

> nameEx("draw.gamlss")
> ### * draw.gamlss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.gamlss
> ### Title: Plot smooths of a GAMLSS model estimated by 'GJRM::gamlss'
> ### Aliases: draw.gamlss
> 
> ### ** Examples
> 
> if (require("GJRM", quietly = TRUE)) {
+     # follow example from ?GJRM::gamlss
+     library(GJRM)
+     set.seed(0)
+     n <- 100
+     x1 <- round(runif(n))
+     x2 <- runif(n)
+     x3 <- runif(n)
+     f1 <- function(x) cos(pi*2*x) + sin(pi*x)
+     y1 <- -1.55 + 2*x1 + f1(x2) + rnorm(n)
+     dataSim <- data.frame(y1, x1, x2, x3)
+ 
+     eq_mu <- y1 ~ x1 + s(x2)
+     eq_s  <-    ~ s(x3, k = 6)
+     fl    <- list(eq_mu, eq_s)
+     m <- gamlss(fl, data = dataSim)
+ 
+     draw(m)
+ }
This is mgcv 1.8-41. For overview type 'help("mgcv-package")'.

This is GJRM 0.2-6.1.
For overview type 'help("GJRM-package")'.

> 
> 
> 
> cleanEx()

detaching ‘package:GJRM’, ‘package:mgcv’, ‘package:nlme’

> nameEx("draw.mgcv_smooth")
> ### * draw.mgcv_smooth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.mgcv_smooth
> ### Title: Plot basis functions
> ### Aliases: draw.mgcv_smooth
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg4", n = 400, seed = 42)
> 
> bf <- basis(s(x0), data = df)
> draw(bf)
> 
> bf <- basis(s(x2, by = fac, bs = "bs"), data = df)
> draw(bf)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.penalty_df")
> ### * draw.penalty_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.penalty_df
> ### Title: Display penalty matrices of smooths using 'ggplot'
> ### Aliases: draw.penalty_df
> 
> ### ** Examples
> 
> load_mgcv()
> dat <- data_sim("eg4", n = 400, seed = 42)
> m <- gam(y ~ s(x0) + s(x1, bs = 'cr') + s(x2, bs = 'bs', by = fac),
+          data = dat, method = "REML")
> 
> ## produce a multi-panel plot of all penalties
> draw(penalty(m))
> 
> # for a specific smooth
> draw(penalty(m, smooth = "s(x2):fac1"))
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.rootogram")
> ### * draw.rootogram
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.rootogram
> ### Title: Draw a rootogram
> ### Aliases: draw.rootogram
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", n = 1000, dist = "poisson", scale = 0.1, seed = 6)
> 
> # A poisson example
> m <- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") + s(x2, bs = "cr") +
+          s(x3, bs = "cr"), family = poisson(), data = df, method = "REML")
> rg <- rootogram(m)
> 
> # plot the rootogram
> draw(rg)
> 
> # change the type of rootogram
> draw(rg, type = "suspended")
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.smooth_estimates")
> ### * draw.smooth_estimates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.smooth_estimates
> ### Title: Plot the result of a call to 'smooth_estimates()'
> ### Aliases: draw.smooth_estimates
> 
> ### ** Examples
> 
> load_mgcv()
> # example data
> df <- data_sim("eg1", seed = 21)
> # fit GAM
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> # plot all of the estimated smooths
> sm <- smooth_estimates(m)
> draw(sm)
> # evaluate smooth of `x2`
> sm <- smooth_estimates(m, smooth = "s(x2)")
> # plot it
> draw(sm)
> 
> # customising some plot elements
> draw(sm, ci_col = "steelblue", smooth_col = "forestgreen", ci_alpha = 0.3)
> 
> # Add a constant to the plotted smooth
> draw(sm, constant = coef(m)[1])
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.smooth_samples")
> ### * draw.smooth_samples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.smooth_samples
> ### Title: Plot posterior smooths
> ### Aliases: draw.smooth_samples
> 
> ### ** Examples
> 
> load_mgcv()
> dat1 <- data_sim("eg1", n = 400, dist = "normal", scale = 1, seed = 1)
> ## a single smooth GAM
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat1, method = "REML")
> ## posterior smooths from m1
> sm1 <- smooth_samples(m1, n = 15, seed = 23478)
> ## plot
> draw(sm1, alpha = 0.7)
> ## plot only 5 randomly smapled draws
> draw(sm1, n_samples = 5, alpha = 0.7)
> 
> ## A factor-by smooth example
> dat2 <- data_sim("eg4", n = 400, dist = "normal", scale = 1, seed = 1)
> ## a multi-smooth GAM with a factor-by smooth
> m2 <- gam(y ~ fac + s(x2, by = fac) + s(x0), data = dat2, method = "REML")
> ## posterior smooths from m1
> sm2 <- smooth_samples(m2, n = 15, seed = 23478)
> ## plot, this time selecting only the factor-by smooth
> draw(sm2, select = "s(x2)", partial_match = TRUE, alpha = 0.7)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("edf")
> ### * edf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edf
> ### Title: Effective degrees of freedom for smooths and GAMs
> ### Aliases: edf edf.gam model_edf
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 5)
> ## End(Don't show)
> df <- data_sim("eg1", n = 400, seed = 42)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> # extract the EDFs for all smooths
> edf(m)
# A tibble: 4 x 2
  smooth    edf
  <chr>   <dbl>
1 s(x0)  3.4248
2 s(x1)  3.2213
3 s(x2)  7.9049
4 s(x3)  1.8847
> 
> # or selected smooths
> edf(m, smooth = c("s(x0)", "s(x2)"))
# A tibble: 2 x 2
  smooth    edf
  <chr>   <dbl>
1 s(x0)  3.4248
2 s(x2)  7.9049
> 
> # accounting for smoothness parameter uncertainty
> edf(m, type = "unconditional")
# A tibble: 4 x 2
  smooth    edf
  <chr>   <dbl>
1 s(x0)  3.7697
2 s(x1)  3.8728
3 s(x2)  8.0670
4 s(x3)  2.8834
> 
> # over EDF of the model, including the intercept
> model_edf(m)
# A tibble: 1 x 2
  model    edf
  <chr>  <dbl>
1 m     17.436
> 
> # can get model EDF for multiple models
> m2 <- gam(y ~ s(x0) + s(x1) + s(x3), data = df, method = "REML")
> model_edf(m, m2)
# A tibble: 2 x 2
  model     edf
  <chr>   <dbl>
1 m     17.436 
2 m2     7.5777
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("evaluate_smooth")
> ### * evaluate_smooth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: evaluate_smooth
> ### Title: Evaluate a smooth
> ### Aliases: evaluate_smooth evaluate_smooth.gam evaluate_smooth.gamm
> ###   evaluate_smooth.list
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 2)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 500, dist = "normal", scale = 1, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> evaluate_smooth(m1, "s(x1)")
# A tibble: 100 x 5
   smooth by_variable     x1   est    se
   <chr>  <fct>        <dbl> <dbl> <dbl>
 1 s(x1)  <NA>        0.0025  -2.1 0.17 
 2 s(x1)  <NA>        0.013   -2.1 0.15 
 3 s(x1)  <NA>        0.023   -2.1 0.14 
 4 s(x1)  <NA>        0.033   -2.0 0.13 
 5 s(x1)  <NA>        0.043   -2.0 0.12 
 6 s(x1)  <NA>        0.053   -2.0 0.11 
 7 s(x1)  <NA>        0.063   -2.0 0.11 
 8 s(x1)  <NA>        0.073   -2.0 0.10 
 9 s(x1)  <NA>        0.083   -2.0 0.10 
10 s(x1)  <NA>        0.093   -2.0 0.097
# ... with 90 more rows
> 
> ## 2d example
> dat <- data_sim("eg2", n = 1000, dist = "normal", scale = 1, seed = 2)
> m2 <- gam(y ~ s(x, z, k = 30), data = dat, method = "REML")
> 
> evaluate_smooth(m2, "s(x,z)", n = 50)
# A tibble: 2,500 x 6
   smooth by_variable       x       z   est    se
   <chr>  <fct>         <dbl>   <dbl> <dbl> <dbl>
 1 s(x,z) <NA>        0.00066 0.00076 0.088  0.19
 2 s(x,z) <NA>        0.021   0.00076 0.097  0.18
 3 s(x,z) <NA>        0.041   0.00076 0.11   0.18
 4 s(x,z) <NA>        0.062   0.00076 0.12   0.17
 5 s(x,z) <NA>        0.082   0.00076 0.13   0.16
 6 s(x,z) <NA>        0.10    0.00076 0.14   0.16
 7 s(x,z) <NA>        0.12    0.00076 0.14   0.15
 8 s(x,z) <NA>        0.14    0.00076 0.15   0.15
 9 s(x,z) <NA>        0.16    0.00076 0.16   0.14
10 s(x,z) <NA>        0.18    0.00076 0.17   0.14
# ... with 2,490 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("evenly")
> ### * evenly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: evenly
> ### Title: Create a sequence of evenly-spaced values
> ### Aliases: evenly seq_min_max
> 
> ### ** Examples
> 
> ## Don't show: 
> set.seed(1)
> ## End(Don't show)
> x <- rnorm(10)
> n <- 10L
> evenly(x, n = n)
 [1] -0.83562861 -0.56552757 -0.29542652 -0.02532547  0.24477557  0.51487662
 [7]  0.78497766  1.05507871  1.32517976  1.59528080
> 
> 
> 
> cleanEx()
> nameEx("fderiv")
> ### * fderiv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fderiv
> ### Title: First derivatives of fitted GAM functions
> ### Aliases: fderiv fderiv.gam fderiv.gamm
> ### Keywords: internal
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(lifecycle_verbosity = "quiet")
> ## End(Don't show)
> dat <- data_sim("eg1", seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> ## first derivatives of all smooths...
> fd <- fderiv(mod)
> ## now use -->
> fd <- derivatives(mod)
> 
> ## ...and a selected smooth
> fd2 <- fderiv(mod, term = "x1")
> ## now use -->
> fd2 <- derivatives(mod, term = "s(x1)")
> 
> ## Models with factors
> dat <- data_sim("eg4", n = 400, dist = "normal", scale = 2, seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + fac, data = dat, method = "REML")
> 
> ## first derivatives of all smooths...
> fd <- fderiv(mod)
> ## now use -->
> fd <- derivatives(mod)
> 
> ## ...and a selected smooth
> fd2 <- fderiv(mod, term = "x1")
> ## now use -->
> fd2 <- derivatives(mod, term = "s(x1)")
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("fitted_samples")
> ### * fitted_samples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitted_samples
> ### Title: Draw fitted values from the posterior distribution
> ### Aliases: fitted_samples fitted_samples.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> fs <- fitted_samples(m1, n = 5, seed = 42)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("fitted_values")
> ### * fitted_values
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitted_values
> ### Title: Generate fitted values from a estimated GAM
> ### Aliases: fitted_values fitted_values.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 6)
> ## End(Don't show)
> sim_df <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = sim_df, method = "REML")
> fv <- fitted_values(m)
> fv
# A tibble: 400 x 8
         x0        x1         x2       x3   fitted       se    lower    upper
      <dbl>     <dbl>      <dbl>    <dbl>    <dbl>    <dbl>    <dbl>    <dbl>
 1 0.184882 0.617142  0.415244   0.132410  8.73875 0.354677  8.04360  9.43390
 2 0.702374 0.569064  0.531439   0.365331  7.62581 0.337779  6.96378  8.28785
 3 0.573326 0.153970  0.00324621 0.454532  3.12106 0.591862  1.96103  4.28109
 4 0.168052 0.0348332 0.252100   0.537114 11.1124  0.402378 10.3237  11.9010 
 5 0.943839 0.997953  0.155229   0.185495 14.0533  0.452947 13.1655  14.9411 
 6 0.943475 0.835574  0.878840   0.449276  6.13080 0.364521  5.41635  6.84525
 7 0.129159 0.586562  0.203511   0.256527 12.4838  0.355808 11.7864  13.1812 
 8 0.833449 0.339117  0.583528   0.618458  6.25215 0.344700  5.57655  6.92775
 9 0.468019 0.166883  0.804473   0.880744  4.21463 0.372003  3.48552  4.94374
10 0.549984 0.807410  0.264717   0.317747 15.5283  0.369999 14.8031  16.2535 
# ... with 390 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("fix_offset")
> ### * fix_offset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fix_offset
> ### Title: Fix the names of a data frame containing an offset variable.
> ### Aliases: fix_offset
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> set.seed(2)
> ## End(Don't show)
> df <- data_sim("eg1", n = 400, dist = "normal", seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + offset(x2), data = df, method = "REML")
> names(model.frame(m))
[1] "y"          "offset(x2)" "x0"         "x1"        
> names(fix_offset(m, model.frame(m), offset_val = 1L))
[1] "y"  "x2" "x0" "x1"
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("fixef.gam")
> ### * fixef.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fixef.gam
> ### Title: Extract fixed effects estimates from a fitted GAM
> ### Aliases: fixef.gam fixef.gamm fixef.lm fixef.glm fixed_effects
> ###   fixed_effects.default
> 
> ### ** Examples
> 
> load_mgcv()
> 
> # run example if lme4 is available
> if (require("lme4")) {
+ 
+ data(sleepstudy, package = "lme4")
+ m <- gam(Reaction ~ Days + s(Subject, bs = "re") +
+            s(Days, Subject, bs = "re"),
+          data = sleepstudy, method = "REML")
+ fixef(m)
+ 
+ }
Loading required package: lme4
Loading required package: Matrix
(Intercept)        Days 
  251.40510    10.46729 
> 
> 
> 
> cleanEx()

detaching ‘package:lme4’, ‘package:Matrix’, ‘package:mgcv’

> nameEx("gw_functions")
> ### * gw_functions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gw_f0
> ### Title: Gu and Wabha test functions
> ### Aliases: gw_f0 gw_f1 gw_f2 gw_f3
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(digits = 4)
> ## End(Don't show)
> x <- seq(0, 1, length = 6)
> gw_f0(x)
[1] 0.000e+00 1.176e+00 1.902e+00 1.902e+00 1.176e+00 2.449e-16
> gw_f1(x)
[1] 1.000 1.492 2.226 3.320 4.953 7.389
> gw_f2(x)
[1] 0.000 8.591 4.261 3.199 1.100 0.000
> gw_f3(x) # should be constant 0
[1] 0 0 0 0 0 0
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("has_theta")
> ### * has_theta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: has_theta
> ### Title: Are additional parameters available for a GAM?
> ### Aliases: has_theta
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", dist = "poisson", seed = 42, scale = 1/5)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML",
+          family = nb())
> has_theta(m)
[1] TRUE
> p <- theta(m)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("is_offset")
> ### * is_offset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_offset
> ### Title: Is a model term an offset?
> ### Aliases: is_offset
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", n = 400, dist = "normal")
> m <- gam(y ~ s(x0) + s(x1) + offset(x0), data = df, method = "REML")
> nm <- names(model.frame(m))
> nm
[1] "y"          "offset(x0)" "x0"         "x1"        
> is_offset(nm)
[1] FALSE  TRUE FALSE FALSE
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("link")
> ### * link
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: link
> ### Title: Extract link and inverse link functions from models
> ### Aliases: link link.family link.gam link.bam link.gamm link.glm
> ###   link.list inv_link inv_link.family inv_link.gam inv_link.bam
> ###   inv_link.gamm inv_link.list inv_link.glm extract_link
> ###   extract_link.family extract_link.general.family
> 
> ### ** Examples
> 
> load_mgcv()
> 
> link(gaussian())
function (mu) 
mu
<environment: namespace:stats>
> link(nb())
function (mu) 
log(mu)
<environment: namespace:stats>
> 
> inv_link(nb())
function (eta) 
pmax(exp(eta), .Machine$double.eps)
<environment: namespace:stats>
> 
> dat <- data_sim("eg1", seed = 4234)
> mod <- gam(list(y ~ s(x0) + s(x1) + s(x2) + s(x3), ~ 1), data = dat,
+            family = gaulss)
> 
> link(mod, parameter = "scale")
function (mu) 
log(1/mu - 0.01)
<environment: 0x55dc6aad4d28>
> inv_link(mod, parameter = "scale")
function (eta) 
1/(exp(eta) + 0.01)
<environment: 0x55dc6aad4d28>
> 
> ## Works with `family` objects too
> link(shash(), parameter = "skewness")
function (mu) 
mu
<environment: namespace:stats>
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("lp_matrix")
> ### * lp_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lp_matrix
> ### Title: Return the linear prediction matrix of a fitted GAM
> ### Aliases: lp_matrix lp_matrix.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", seed = 1)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df)
> 
> # linear prediction matrix for observed data
> xp <- lp_matrix(m)
> ## IGNORE_RDIFF_BEGIN
> xp
Linear prediction matrix (400 x 37)
  `(Intercept)` s(x0).~1 s(x0)~2 s(x0)~3 s(x0)~4 s(x0)~5 s(x0)~6 s(x0)~7 s(x0)~8
  <matrix>      <matrix> <matri> <matri> <matri> <matri> <matri> <matri> <matri>
1 1              0.9611~  0.227~  0.705~  0.134~  0.457~ -0.146~  0.620~  0.201~
2 1              0.6513~ -0.240~  0.068~  0.308~  0.394~ -0.009~  0.355~  0.418~
3 1             -0.3847~ -0.549~  0.066~  0.204~ -0.415~ -0.247~ -0.034~  0.462~
4 1             -1.2733~  0.155~ -1.534~ -0.222~ -1.598~  0.197~ -1.583~ -0.747~
5 1              1.0510~  0.420~  1.113~ -0.213~  0.892~  0.035~  0.776~ -0.028~
# ... with 395 more rows, 28 more variables: `s(x0).9` <matrix>, ...
> ## IGNORE_RDIFF_END
> 
> # the object `xp` *is* a matrix
> class(xp)
[1] "lp_matrix" "matrix"    "array"    
> # but we print like a tibble to avoid spamming the R console
> 
> # linear predictor matrix for new data set
> ds <- data_slice(m, x2 = evenly(x2))
> xp <- lp_matrix(m, data = ds)
> ## IGNORE_RDIFF_BEGIN
> xp
Linear prediction matrix (100 x 37)
  `(Intercept)` s(x0).~1 s(x0)~2 s(x0)~3 s(x0)~4 s(x0)~5 s(x0)~6 s(x0)~7 s(x0)~8
  <matrix>      <matrix> <matri> <matri> <matri> <matri> <matri> <matri> <matri>
1 1             0.16990~ -0.541~ -0.037~ 0.0534~ 0.1444~ -0.353~ -0.057~ 0.5181~
2 1             0.16990~ -0.541~ -0.037~ 0.0534~ 0.1444~ -0.353~ -0.057~ 0.5181~
3 1             0.16990~ -0.541~ -0.037~ 0.0534~ 0.1444~ -0.353~ -0.057~ 0.5181~
4 1             0.16990~ -0.541~ -0.037~ 0.0534~ 0.1444~ -0.353~ -0.057~ 0.5181~
5 1             0.16990~ -0.541~ -0.037~ 0.0534~ 0.1444~ -0.353~ -0.057~ 0.5181~
# ... with 95 more rows, 28 more variables: `s(x0).9` <matrix>, ...
> ## IGNORE_RDIFF_END
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("model_concurvity")
> ### * model_concurvity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model_concurvity
> ### Title: Concurvity of an estimated GAM
> ### Aliases: model_concurvity model_concurvity.gam concrvity
> 
> ### ** Examples
> 
> ## simulate data with concurvity...
> library("tibble")
> load_mgcv()
> set.seed(8)
> n <- 200
> df <- tibble(t = sort(runif(n)),
+              x = gw_f2(t) + rnorm(n) * 3,
+              y = sin(4 * pi * t) + exp(x / 20) + rnorm(n) * 0.3)
> 
> ## fit model
> m <- gam(y ~ s(t, k = 15) + s(x, k = 15), data = df, method = "REML")
> 
> ## overall concurvity
> o_conc <- concrvity(m)
> draw(o_conc)
> 
> ## pairwise concurvity
> p_conc <- concrvity(m, pairwise = TRUE)
> draw(p_conc)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’, ‘package:tibble’

> nameEx("model_vars")
> ### * model_vars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model_vars
> ### Title: List the variables involved in a model fitted with a formula
> ### Aliases: model_vars model_vars.gam model_vars.default model_vars.bam
> ###   model_vars.gamm model_vars.gamm4 model_vars.list
> 
> ### ** Examples
> 
> load_mgcv()
> 
> # simulate some Gaussian data
> df <- data_sim("eg1", n = 50, seed = 2)
> 
> # fit a GAM with 1 smooth and 1 linear term
> m1 <- gam(y ~ s(x2, k = 7) + x1, data = df, method = "REML")
> model_vars(m1)
[1] "x1" "x2"
> 
> # fit a lm with two linear terms
> m2 <- lm(y ~ x2 + x1, data = df)
> model_vars(m2)
[1] "x2" "x1"
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("nb_theta")
> ### * nb_theta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nb_theta
> ### Title: Negative binomial parameter theta
> ### Aliases: nb_theta nb_theta.gam
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", n = 500, dist = "poisson", scale = 0.1, seed = 6)
> 
> m <- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") + s(x2, bs = "cr") +
+          s(x3, bs = "cr"), family = nb, data = df, method = "REML")
> ## IGNORE_RDIFF_BEGIN
> nb_theta(m)
[1] 239398.6
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("overview")
> ### * overview
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: overview
> ### Title: Provides an overview of a model and the terms in that model
> ### Aliases: overview overview.gam
> 
> ### ** Examples
> 
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim(n = 400, seed = 2)
> m <- gam(y ~ x3 + s(x0) + s(x1, bs = "bs") + s(x2, bs = "ts"),
+          data = df, method = "REML")
> overview(m)

Generalized Additive Model with 4 terms

  term  type            edf statistic p.value
  <chr> <chr>         <dbl>     <dbl> <chr>  
1 x3    parametric     1         4.28 0.03926
2 s(x0) TPRS           3.02      6.25 < 0.001
3 s(x1) B spline       2.81     71.0  < 0.001
4 s(x2) TPRS (shrink)  7.91     83.8  < 0.001
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("partial_derivatives")
> ### * partial_derivatives
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: partial_derivatives
> ### Title: Partial derivatives of estimated multivariate smooths via finite
> ###   differences
> ### Aliases: partial_derivatives partial_derivatives.default
> ###   partial_derivatives.gamm partial_derivatives.gam
> 
> ### ** Examples
> 
> 
> library("ggplot2")
> library("patchwork")
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg2", n = 2000, dist = "normal", scale = 0.5, seed = 42)
> 
> # fit the GAM (note: for execution time reasons, k is set articifially low)
> m <- gam(y ~ te(x, z, k = c(5, 5)), data = df, method = "REML")
> 
> # data slice through te(x,z) holding z == 0.4
> ds <- data_slice(m, x = evenly(x, n = 100), z = 0.4)
> 
> # evaluate te(x,z) at values of x & z
> sm <- smooth_estimates(m, smooth = "te(x,z)", data = ds) |>
+     add_confint()
> 
> # partial derivatives
> pd_x <- partial_derivatives(m, data = ds, type = "central", focal = "x")
> 
> # draw te(x,z)
> p1 <- draw(m, rug = FALSE) &
+     geom_hline(yintercept = 0.4, linewidth = 1)
> p1
> 
> # draw te(x,z) along slice
> cap <- expression(z == 0.4)
> p2 <- sm |>
+     ggplot(aes(x = x, y = est)) +
+     geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), alpha = 0.2) +
+     geom_line() +
+     labs(x = "x", y = "Partial effect", title = "te(x,z)",
+         caption = cap)
> p2
> 
> # draw partial derivs
> p3 <- pd_x |>
+     draw() +
+     labs(caption = cap)
> p3
> 
> # draw all three panels
> p1 + p2 + p3 + plot_layout(ncol = 3)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’, ‘package:patchwork’, ‘package:ggplot2’

> nameEx("partial_residuals")
> ### * partial_residuals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: partial_residuals
> ### Title: Partial residuals
> ### Aliases: partial_residuals partial_residuals.gam
> 
> ### ** Examples
> 
> ## Don't show: 
> set.seed(1)
> op <- options(pillar.sigfig = 4, cli.unicode = FALSE)
> ## End(Don't show)
> ## load mgcv
> load_mgcv()
> 
> ## example data - Gu & Wabha four term model
> df <- data_sim("eg1", n = 400, seed = 42)
> ## fit the model
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = 'REML')
> 
> ## extract partial residuals
> partial_residuals(m)
# A tibble: 400 x 4
   `s(x0)`  `s(x1)` `s(x2)`  `s(x3)`
     <dbl>    <dbl>   <dbl>    <dbl>
 1 -0.3527 -1.321   -2.180   0.6077 
 2 -0.1233  0.5013  -1.775   0.9613 
 3  1.429   1.515    5.609   0.9910 
 4 -1.110  -1.700   -0.8882 -0.6593 
 5 -2.120  -0.01378 -2.733  -3.012  
 6  1.254  -1.224    3.915   0.07275
 7 -0.5220  3.023   -0.8197 -1.019  
 8  1.398   0.2184   7.055   1.897  
 9  2.797   0.4969   7.329   2.498  
10  1.151  -0.2267   0.7202  0.7437 
# ... with 390 more rows
> 
> ## and for a select term
> partial_residuals(m, select = "s(x2)")
# A tibble: 400 x 1
   `s(x2)`
     <dbl>
 1 -2.180 
 2 -1.775 
 3  5.609 
 4 -0.8882
 5 -2.733 
 6  3.915 
 7 -0.8197
 8  7.055 
 9  7.329 
10  0.7202
# ... with 390 more rows
> 
> ## or with partial matching
> partial_residuals(m, select = "x", partial_match = TRUE) # returns all
# A tibble: 400 x 4
   `s(x0)`  `s(x1)` `s(x2)`  `s(x3)`
     <dbl>    <dbl>   <dbl>    <dbl>
 1 -0.3527 -1.321   -2.180   0.6077 
 2 -0.1233  0.5013  -1.775   0.9613 
 3  1.429   1.515    5.609   0.9910 
 4 -1.110  -1.700   -0.8882 -0.6593 
 5 -2.120  -0.01378 -2.733  -3.012  
 6  1.254  -1.224    3.915   0.07275
 7 -0.5220  3.023   -0.8197 -1.019  
 8  1.398   0.2184   7.055   1.897  
 9  2.797   0.4969   7.329   2.498  
10  1.151  -0.2267   0.7202  0.7437 
# ... with 390 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("penalty")
> ### * penalty
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: penalty
> ### Title: Extract and tidy penalty matrices
> ### Aliases: penalty penalty.gam penalty.mgcv.smooth penalty.tensor.smooth
> ###   penalty.t2.smooth penalty.re.smooth.spec
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 3)
> ## End(Don't show)
> load_mgcv()
> dat <- data_sim("eg4", n = 400, seed = 42)
> m <- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") +
+            s(x2, by = fac, bs = "cr"),
+          data = dat, method = "REML")
> 
> # penalties for all smooths
> penalty(m)
# A tibble: 405 x 6
   smooth type  penalty row   col     value
   <chr>  <chr> <chr>   <chr> <chr>   <dbl>
 1 s(x0)  CRS   s(x0)   F1    F1     0.783 
 2 s(x0)  CRS   s(x0)   F1    F2    -0.635 
 3 s(x0)  CRS   s(x0)   F1    F3     0.265 
 4 s(x0)  CRS   s(x0)   F1    F4    -0.0203
 5 s(x0)  CRS   s(x0)   F1    F5     0.0441
 6 s(x0)  CRS   s(x0)   F1    F6     0.0378
 7 s(x0)  CRS   s(x0)   F1    F7     0.0482
 8 s(x0)  CRS   s(x0)   F1    F8     0.0216
 9 s(x0)  CRS   s(x0)   F1    F9     0.0247
10 s(x0)  CRS   s(x0)   F2    F1    -0.635 
# ... with 395 more rows
> 
> # for a specific smooth
> penalty(m, smooth = "s(x2):fac1")
# A tibble: 81 x 6
   smooth     type  penalty    row   col     value
   <chr>      <chr> <chr>      <chr> <chr>   <dbl>
 1 s(x2):fac1 CRS   s(x2):fac1 F1    F1     1.66  
 2 s(x2):fac1 CRS   s(x2):fac1 F1    F2    -0.755 
 3 s(x2):fac1 CRS   s(x2):fac1 F1    F3     0.430 
 4 s(x2):fac1 CRS   s(x2):fac1 F1    F4     0.0846
 5 s(x2):fac1 CRS   s(x2):fac1 F1    F5     0.192 
 6 s(x2):fac1 CRS   s(x2):fac1 F1    F6     0.152 
 7 s(x2):fac1 CRS   s(x2):fac1 F1    F7     0.188 
 8 s(x2):fac1 CRS   s(x2):fac1 F1    F8     0.164 
 9 s(x2):fac1 CRS   s(x2):fac1 F1    F9     0.0597
10 s(x2):fac1 CRS   s(x2):fac1 F2    F1    -0.755 
# ... with 71 more rows
> 
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("predicted_samples")
> ### * predicted_samples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predicted_samples
> ### Title: Draw new response values from the conditional distribution of
> ###   the response
> ### Aliases: predicted_samples predicted_samples.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> predicted_samples(m, n = 5, seed = 42)
# A tibble: 5,000 x 3
     row  draw response
   <int> <int>    <dbl>
 1     1     1     8.93
 2     2     1     4.23
 3     3     1     7.71
 4     4     1     8.51
 5     5     1    10.1 
 6     6     1     8.20
 7     7     1     8.95
 8     8     1     7.20
 9     9     1    18.1 
10    10     1    12.7 
# ... with 4,990 more rows
> 
> ## Can pass arguments to predict.gam()
> ## Don't show: 
> set.seed(6791)
> ## End(Don't show)
> newd <- data.frame(x0 = runif(10), x1 = runif(10), x2 = runif(10),
+                    x3 = runif(10))
> 
> ## Exclude s(x2)
> predicted_samples(m, n = 5, newd, exclude = "s(x2)", seed = 25)
# A tibble: 50 x 3
     row  draw response
   <int> <int>    <dbl>
 1     1     1     9.42
 2     2     1     6.97
 3     3     1     8.10
 4     4     1     9.95
 5     5     1     6.75
 6     6     1    10.3 
 7     7     1    10.8 
 8     8     1    10.5 
 9     9     1     8.43
10    10     1    12.2 
# ... with 40 more rows
> 
> ## Exclude s(x1)
> predicted_samples(m, n = 5, newd, exclude = "s(x1)", seed = 25)
# A tibble: 50 x 3
     row  draw response
   <int> <int>    <dbl>
 1     1     1     6.05
 2     2     1     5.28
 3     3     1     5.96
 4     4     1    13.7 
 5     5     1     4.36
 6     6     1     5.11
 7     7     1    12.5 
 8     8     1     5.66
 9     9     1    12.6 
10    10     1     8.38
# ... with 40 more rows
> 
> ## Select which terms --- result should be the same as previous
> ## but note that we have to include any parametric terms, including the
> ## constant term
> predicted_samples(m, n = 5, newd, seed = 25,
+                   terms = c("Intercept", "s(x0)", "s(x2)", "s(x3)"))
# A tibble: 50 x 3
     row  draw response
   <int> <int>    <dbl>
 1     1     1   -1.94 
 2     2     1   -2.71 
 3     3     1   -2.03 
 4     4     1    5.73 
 5     5     1   -3.63 
 6     6     1   -2.87 
 7     7     1    4.48 
 8     8     1   -2.33 
 9     9     1    4.65 
10    10     1    0.395
# ... with 40 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("qq_plot")
> ### * qq_plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qq_plot
> ### Title: Quantile-quantile plot of model residuals
> ### Aliases: qq_plot qq_plot.default qq_plot.gam qq_plot.glm qq_plot.lm
> 
> ### ** Examples
> 
> load_mgcv()
> ## simulate binomial data...
> dat <- data_sim("eg1", n = 200, dist = "binary", scale = .33, seed = 0)
> p <- binomial()$linkinv(dat$f)               # binomial p
> n <- sample(c(1, 3), 200, replace = TRUE) # binomial n
> dat <- transform(dat, y = rbinom(n, n, p), n = n)
> m <- gam( y / n ~ s(x0) + s(x1) + s(x2) + s(x3),
+          family = binomial, data = dat, weights = n,
+          method = "REML")
> 
> ## Q-Q plot; default using direct randomization of uniform quantiles
> qq_plot(m)
> 
> ## Alternatively use simulate new data from the model, which
> ## allows construction of reference intervals for the Q-Q plot
> qq_plot(m, method = "simulate", point_col = "steelblue",
+         point_alpha = 0.4)
> 
> ## ... or use the usual normality assumption
> qq_plot(m, method = "normal")
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("ref_level")
> ### * ref_level
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ref_level
> ### Title: Return the reference or specific level of a factor
> ### Aliases: ref_level level
> 
> ### ** Examples
> 
> ## Don't show: 
> set.seed(1)
> ## End(Don't show)
> f <- factor(sample(letters[1:5], 100, replace = TRUE))
> 
> # the reference level
> ref_level(f)
[1] a
Levels: a b c d e
> 
> # a specific level
> level(f, level = "b")
[1] b
Levels: a b c d e
> 
> # note that the levels will always match the input factor
> identical(levels(f), levels(ref_level(f)))
[1] TRUE
> identical(levels(f), levels(level(f, "c")))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("rootogram")
> ### * rootogram
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rootogram
> ### Title: Rootograms to assess goodness of model fit
> ### Aliases: rootogram rootogram.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 6)
> ## End(Don't show)
> df <- data_sim("eg1", n = 1000, dist = "poisson", scale = 0.1, seed = 6)
> 
> # A poisson example
> m <- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") + s(x2, bs = "cr") +
+          s(x3, bs = "cr"), family = poisson(), data = df, method = "REML")
> rg <- rootogram(m)
> rg
# A tibble: 21 x 3
     bin observed    fitted
   <dbl>    <int>     <dbl>
 1     0      113 116.640  
 2     1      236 227.869  
 3     2      230 239.168  
 4     3      200 181.679  
 5     4       94 113.432  
 6     5       68  62.4881 
 7     6       27  31.6795 
 8     7       22  15.1323 
 9     8        4   6.88637
10     9        3   2.99628
# ... with 11 more rows
> draw(rg) # plot the rootogram
> 
> # A Gaussian example
> df <- data_sim("eg1", dist = "normal", seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> draw(rootogram(m, breaks = "FD"), type = "suspended")
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("simulate")
> ### * simulate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate.gam
> ### Title: Simulate from the posterior distribution of a GAM
> ### Aliases: simulate.gam simulate.gamm simulate.scam
> 
> ### ** Examples
> 
> load_mgcv()
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> sims <- simulate(m1, nsim = 5, seed = 42)
> head(sims)
          [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 11.445470 11.374304 10.098681  7.264881  8.796630
[2,]  6.510912  5.909584  9.057362  7.698084 11.444781
[3,]  3.837995  3.230610  3.550240  3.759380  4.774581
[4,] 12.361830 11.209226 10.714215 11.861957 10.746417
[5,] 14.851461 12.911440 11.356984 15.783913 15.106270
[6,]  5.921276  4.158963  5.520856  7.973614  9.654888
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("smooth_coefs")
> ### * smooth_coefs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smooth_coefs
> ### Title: Coefficients for a particular smooth
> ### Aliases: smooth_coefs smooth_coefs.gam smooth_coefs.bam
> ###   smooth_coefs.gamm smooth_coefs.gamm4 smooth_coefs.list
> ###   smooth_coefs.mgcv.smooth smooth_coefs.scam
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> load_mgcv()
> df <- data_sim("eg1", seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> ## IGNORE_RDIFF_BEGIN
> smooth_coefs(m, term = "s(x2)")
  s(x2).1   s(x2).2   s(x2).3   s(x2).4   s(x2).5   s(x2).6   s(x2).7   s(x2).8 
-6.533373  9.694277  2.194078  1.967280 -2.374874  1.207638 -1.572586  9.269744 
  s(x2).9 
 5.622738 
> ## IGNORE_RDIFF_END
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("smooth_data")
> ### * smooth_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smooth_data
> ### Title: Generate regular data over the covariates of a smooth
> ### Aliases: smooth_data
> 
> ### ** Examples
> 
> 
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 4)
> ## End(Don't show)
> load_mgcv()
> df <- data_sim("eg1", seed = 42)
> m <- bam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df)
> 
> # generate data over range of x1 for smooth s(x1)
> smooth_data(m, id = 2)
# A tibble: 100 x 1
          x1
       <dbl>
 1 0.0004050
 2 0.01046  
 3 0.02052  
 4 0.03057  
 5 0.04063  
 6 0.05069  
 7 0.06074  
 8 0.07080  
 9 0.08086  
10 0.09091  
# ... with 90 more rows
> 
> # generate data over range of x1 for smooth s(x1), with typical value for
> # other covariates in the model
> smooth_data(m, id = 2, include_all = TRUE)
# A tibble: 100 x 4
          x1     x0     x2     x3
       <dbl>  <dbl>  <dbl>  <dbl>
 1 0.0004050 0.4883 0.4708 0.4879
 2 0.01046   0.4883 0.4708 0.4879
 3 0.02052   0.4883 0.4708 0.4879
 4 0.03057   0.4883 0.4708 0.4879
 5 0.04063   0.4883 0.4708 0.4879
 6 0.05069   0.4883 0.4708 0.4879
 7 0.06074   0.4883 0.4708 0.4879
 8 0.07080   0.4883 0.4708 0.4879
 9 0.08086   0.4883 0.4708 0.4879
10 0.09091   0.4883 0.4708 0.4879
# ... with 90 more rows
> 
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("smooth_estimates")
> ### * smooth_estimates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smooth_estimates
> ### Title: Evaluate smooths at covariate values
> ### Aliases: smooth_estimates smooth_estimates.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 6)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> ## evaluate all smooths
> smooth_estimates(m1)
# A tibble: 400 x 9
   smooth type  by          est       se         x0    x1    x2    x3
   <chr>  <chr> <chr>     <dbl>    <dbl>      <dbl> <dbl> <dbl> <dbl>
 1 s(x0)  TPRS  <NA>  -0.966542 0.316118 0.00710904    NA    NA    NA
 2 s(x0)  TPRS  <NA>  -0.925391 0.297170 0.0171157     NA    NA    NA
 3 s(x0)  TPRS  <NA>  -0.884233 0.279256 0.0271224     NA    NA    NA
 4 s(x0)  TPRS  <NA>  -0.843050 0.262594 0.0371291     NA    NA    NA
 5 s(x0)  TPRS  <NA>  -0.801824 0.247376 0.0471358     NA    NA    NA
 6 s(x0)  TPRS  <NA>  -0.760536 0.233728 0.0571425     NA    NA    NA
 7 s(x0)  TPRS  <NA>  -0.719175 0.221701 0.0671492     NA    NA    NA
 8 s(x0)  TPRS  <NA>  -0.677736 0.211261 0.0771559     NA    NA    NA
 9 s(x0)  TPRS  <NA>  -0.636220 0.202303 0.0871626     NA    NA    NA
10 s(x0)  TPRS  <NA>  -0.594641 0.194685 0.0971693     NA    NA    NA
# ... with 390 more rows
> 
> ## or selected smooths
> smooth_estimates(m1, smooth = c("s(x0)", "s(x1)"))
# A tibble: 200 x 7
   smooth type  by          est       se         x0    x1
   <chr>  <chr> <chr>     <dbl>    <dbl>      <dbl> <dbl>
 1 s(x0)  TPRS  <NA>  -0.966542 0.316118 0.00710904    NA
 2 s(x0)  TPRS  <NA>  -0.925391 0.297170 0.0171157     NA
 3 s(x0)  TPRS  <NA>  -0.884233 0.279256 0.0271224     NA
 4 s(x0)  TPRS  <NA>  -0.843050 0.262594 0.0371291     NA
 5 s(x0)  TPRS  <NA>  -0.801824 0.247376 0.0471358     NA
 6 s(x0)  TPRS  <NA>  -0.760536 0.233728 0.0571425     NA
 7 s(x0)  TPRS  <NA>  -0.719175 0.221701 0.0671492     NA
 8 s(x0)  TPRS  <NA>  -0.677736 0.211261 0.0771559     NA
 9 s(x0)  TPRS  <NA>  -0.636220 0.202303 0.0871626     NA
10 s(x0)  TPRS  <NA>  -0.594641 0.194685 0.0971693     NA
# ... with 190 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("smooth_samples")
> ### * smooth_samples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smooth_samples
> ### Title: Posterior draws for individual smooths
> ### Aliases: smooth_samples smooth_samples.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 3)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 400, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> sms <- smooth_samples(m1, term = "s(x0)", n = 5, seed = 42)
> 
> ## A factor by example (with a spurious covariate x0)
> dat <- data_sim("eg4", n = 1000, seed = 2)
> 
> ## fit model...
> m2 <- gam(y ~ fac + s(x2, by = fac) + s(x0), data = dat)
> sms <- smooth_samples(m2, n = 5, seed = 42)
> draw(sms)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("theta")
> ### * theta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: theta
> ### Title: General extractor for additional parameters in mgcv models
> ### Aliases: theta theta.gam
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", dist = "poisson", seed = 42, scale = 1/5)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML",
+          family = nb())
> p <- theta(m)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("tidy_basis")
> ### * tidy_basis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tidy_basis
> ### Title: A tidy basis representation of a smooth object
> ### Aliases: tidy_basis
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", n = 400, seed = 42)
> 
> # fit model
> m  <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> # tidy representaition of a basis for a smooth definition
> # extract the smooth
> sm <- get_smooth(m, "s(x2)")
> # get the tidy basis - need to pass where we want it to be evaluated
> bf <- tidy_basis(sm, at = df)
> 
> # can weight the basis by the model coefficients for this smooth
> bf <- tidy_basis(sm, at = df, coefs = smooth_coefs(sm, model = m))
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("vars_from_label")
> ### * vars_from_label
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vars_from_label
> ### Title: Returns names of variables from a smooth label
> ### Aliases: vars_from_label
> 
> ### ** Examples
> 
> 
> vars_from_label("s(x1)")
[1] "x1"
> vars_from_label("t2(x1,x2,x3)")
[1] "x1" "x2" "x3"
> 
> 
> 
> cleanEx()
> nameEx("worm_plot")
> ### * worm_plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: worm_plot
> ### Title: Worm plot of model residuals
> ### Aliases: worm_plot worm_plot.gam worm_plot.glm worm_plot.lm
> 
> ### ** Examples
> 
> load_mgcv()
> ## simulate binomial data...
> dat <- data_sim("eg1", n = 200, dist = "binary", scale = .33, seed = 0)
> p <- binomial()$linkinv(dat$f)               # binomial p
> n <- sample(c(1, 3), 200, replace = TRUE) # binomial n
> dat <- transform(dat, y = rbinom(n, n, p), n = n)
> m <- gam( y / n ~ s(x0) + s(x1) + s(x2) + s(x3),
+          family = binomial, data = dat, weights = n,
+          method = "REML")
> 
> ## Worm plot; default using direct randomization of uniform quantiles
> ## Note no reference bands are drawn with this method.
> worm_plot(m)
> 
> ## Alternatively use simulate new data from the model, which
> ## allows construction of reference intervals for the Q-Q plot
> worm_plot(m, method = "simulate", point_col = "steelblue",
+           point_alpha = 0.4)
> 
> ## ... or use the usual normality assumption
> worm_plot(m, method = "normal")
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:mgcv’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  26.158 0.203 26.34 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
