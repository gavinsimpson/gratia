
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "gratia"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('gratia')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("add_fitted.gam")
> ### * add_fitted.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_fitted.gam
> ### Title: Add fitted values from a GAM to a data frame
> ### Aliases: add_fitted.gam
> 
> ### ** Examples
> 
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", seed = 1)
> df <- df[, c("y","x0","x1","x2","x3")]
> m <-  gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> ##
> add_fitted(df, m)
# A tibble: 400 x 6
         y     x0     x1     x2    x3 .fitted
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>   <dbl>
 1  3.34   0.266  0.659  0.859  0.367    5.90
 2 -0.0758 0.372  0.185  0.0344 0.741    3.15
 3 10.7    0.573  0.954  0.971  0.934    8.28
 4  8.73   0.908  0.898  0.745  0.673    8.65
 5 15.0    0.202  0.944  0.273  0.701   15.7 
 6  7.67   0.898  0.724  0.677  0.848    8.38
 7  7.58   0.945  0.370  0.348  0.706    7.84
 8  8.51   0.661  0.781  0.947  0.859    6.74
 9 10.6    0.629  0.0111 0.339  0.446    9.14
10  3.72   0.0618 0.940  0.0317 0.677    7.04
# i 390 more rows
> 
> ## with type = "terms" or "iterms"
> add_fitted(df, m, type = "terms")
# A tibble: 400 x 10
         y     x0     x1     x2    x3 .constant `s(x0)` `s(x1)` `s(x2)` `s(x3)`
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>
 1  3.34   0.266  0.659  0.859  0.367      7.94  0.175    0.559  -2.81   0.0351
 2 -0.0758 0.372  0.185  0.0344 0.741      7.94  0.435   -1.92   -3.23  -0.0687
 3 10.7    0.573  0.954  0.971  0.934      7.94  0.593    3.35   -3.47  -0.122 
 4  8.73   0.908  0.898  0.745  0.673      7.94 -0.812    2.77   -1.19  -0.0498
 5 15.0    0.202  0.944  0.273  0.701      7.94 -0.0589   3.23    4.63  -0.0576
 6  7.67   0.898  0.724  0.677  0.848      7.94 -0.745    1.15    0.146 -0.0981
 7  7.58   0.945  0.370  0.348  0.706      7.94 -1.07    -1.31    2.34  -0.0589
 8  8.51   0.661  0.781  0.947  0.859      7.94  0.434    1.67   -3.20  -0.101 
 9 10.6    0.629  0.0111 0.339  0.446      7.94  0.512   -1.95    2.63   0.0132
10  3.72   0.0618 0.940  0.0317 0.677      7.94 -0.695    3.20   -3.35  -0.0508
# i 390 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("add_partial_residuals")
> ### * add_partial_residuals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_partial_residuals
> ### Title: Add partial residuals
> ### Aliases: add_partial_residuals add_partial_residuals.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", seed = 1)
> df <- df[, c("y","x0","x1","x2","x3")]
> m <-  gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> ## add partial residuals
> add_partial_residuals(df, m)
# A tibble: 400 x 9
         y     x0     x1     x2    x3 `s(x0)` `s(x1)` `s(x2)` `s(x3)`
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>
 1  3.34   0.266  0.659  0.859  0.367  -2.38   -2.00   -5.36  -2.52  
 2 -0.0758 0.372  0.185  0.0344 0.741  -2.79   -5.15   -6.45  -3.29  
 3 10.7    0.573  0.954  0.971  0.934   2.99    5.75   -1.07   2.28  
 4  8.73   0.908  0.898  0.745  0.673  -0.734   2.84   -1.11   0.0287
 5 15.0    0.202  0.944  0.273  0.701  -0.752   2.54    3.94  -0.750 
 6  7.67   0.898  0.724  0.677  0.848  -1.46    0.432  -0.567 -0.812 
 7  7.58   0.945  0.370  0.348  0.706  -1.33   -1.57    2.08  -0.318 
 8  8.51   0.661  0.781  0.947  0.859   2.21    3.44   -1.42   1.68  
 9 10.6    0.629  0.0111 0.339  0.446   2.01   -0.445   4.13   1.51  
10  3.72   0.0618 0.940  0.0317 0.677  -4.02   -0.123  -6.67  -3.37  
# i 390 more rows
> 
> ## add partial residuals for selected smooths
> add_partial_residuals(df, m, select = "s(x0)")
# A tibble: 400 x 6
         y     x0     x1     x2    x3 `s(x0)`
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>   <dbl>
 1  3.34   0.266  0.659  0.859  0.367  -2.38 
 2 -0.0758 0.372  0.185  0.0344 0.741  -2.79 
 3 10.7    0.573  0.954  0.971  0.934   2.99 
 4  8.73   0.908  0.898  0.745  0.673  -0.734
 5 15.0    0.202  0.944  0.273  0.701  -0.752
 6  7.67   0.898  0.724  0.677  0.848  -1.46 
 7  7.58   0.945  0.370  0.348  0.706  -1.33 
 8  8.51   0.661  0.781  0.947  0.859   2.21 
 9 10.6    0.629  0.0111 0.339  0.446   2.01 
10  3.72   0.0618 0.940  0.0317 0.677  -4.02 
# i 390 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("add_residuals.gam")
> ### * add_residuals.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_residuals.gam
> ### Title: Add residuals from a GAM to a data frame
> ### Aliases: add_residuals.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> set.seed(1)
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", seed = 1)
> df <- df[, c("y","x0","x1","x2","x3")]
> m <-  gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = 'REML')
> 
> ##
> add_residuals(df, m)
# A tibble: 400 x 6
         y     x0     x1     x2    x3 .residual
     <dbl>  <dbl>  <dbl>  <dbl> <dbl>     <dbl>
 1  3.34   0.266  0.659  0.859  0.367   -2.56  
 2 -0.0758 0.372  0.185  0.0344 0.741   -3.22  
 3 10.7    0.573  0.954  0.971  0.934    2.40  
 4  8.73   0.908  0.898  0.745  0.673    0.0785
 5 15.0    0.202  0.944  0.273  0.701   -0.693 
 6  7.67   0.898  0.724  0.677  0.848   -0.714 
 7  7.58   0.945  0.370  0.348  0.706   -0.259 
 8  8.51   0.661  0.781  0.947  0.859    1.78  
 9 10.6    0.629  0.0111 0.339  0.446    1.50  
10  3.72   0.0618 0.940  0.0317 0.677   -3.32  
# i 390 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("add_sizer")
> ### * add_sizer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_sizer
> ### Title: Add indicators of significant change after SiZeR
> ### Aliases: add_sizer add_sizer.derivatives add_sizer.smooth_estimates
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 42)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> ## first derivatives of all smooths using central finite differences
> d <- derivatives(mod, type = "central") |>
+     add_sizer()
> 
> # default adds a .change column
> names(d)
 [1] "smooth"     "var"        "by_var"     "fs_var"     "data"      
 [6] "derivative" "se"         "crit"       "lower"      "upper"     
[11] ".change"   
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("appraise")
> ### * appraise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: appraise
> ### Title: Model diagnostic plots
> ### Aliases: appraise appraise.gam appraise.lm
> 
> ### ** Examples
> 
> load_mgcv()
> ## simulate some data...
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat)
> ## run some basic model checks
> appraise(mod, point_col = "steelblue", point_alpha = 0.4)
> 
> ## To change the theme for all panels use the & operator, for example to
> ## change the ggplot theme for all panels
> library("ggplot2")
> appraise(mod, point_col = "steelblue", point_alpha = 0.4,
+          line_col = "black") & theme_minimal()
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:mgcv’

> nameEx("basis")
> ### * basis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: basis
> ### Title: Basis expansions for smooths
> ### Aliases: basis basis.gam basis.scam basis.gamm basis.list basis.default
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg4", n = 400, seed = 42)
> 
> bf <- basis(s(x0), data = df)
> bf <- basis(s(x2, by = fac, bs = "bs"), data = df, constraints = TRUE)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("basis_size")
> ### * basis_size
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: basis_size
> ### Title: Extract basis dimension of a smooth
> ### Aliases: basis_size basis_size.mgcv.smooth basis_size.gam
> ###   basis_size.gamm
> 
> ### ** Examples
> 
> load_mgcv()
> 
> df <- data_sim("eg1", n = 200, seed = 1)
> m <- bam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df)
> 
> basis_size(m)
s(x0) s(x1) s(x2) s(x3) 
    9     9     9     9 
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("compare_smooths")
> ### * compare_smooths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compare_smooths
> ### Title: Compare smooths across models
> ### Aliases: compare_smooths
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 5)
> ## End(Don't show)
> load_mgcv()
> dat <- data_sim("eg1", seed = 2)
> 
> ## models to compare smooths across - artificially create differences
> m1 <- gam(y ~ s(x0, k = 5) + s(x1, k = 5) + s(x2, k = 5) + s(x3, k = 5),
+           data = dat, method = "REML")
> m2 <- gam(y ~ s(x0, bs = 'ts') + s(x1, bs = 'ts') + s(x2, bs = 'ts') +
+           s(x3, bs = 'ts'), data = dat, method = "REML")
> 
> ## build comparisons
> comp <- compare_smooths(m1, m2)
> comp
# A tibble: 8 x 5
  model smooth type          by    data              
  <chr> <chr>  <chr>         <chr> <list>            
1 m1    s(x0)  TPRS          <NA>  <tibble [100 x 3]>
2 m2    s(x0)  TPRS (shrink) <NA>  <tibble [100 x 3]>
3 m1    s(x1)  TPRS          <NA>  <tibble [100 x 3]>
4 m2    s(x1)  TPRS (shrink) <NA>  <tibble [100 x 3]>
5 m1    s(x2)  TPRS          <NA>  <tibble [100 x 3]>
6 m2    s(x2)  TPRS (shrink) <NA>  <tibble [100 x 3]>
7 m1    s(x3)  TPRS          <NA>  <tibble [100 x 3]>
8 m2    s(x3)  TPRS (shrink) <NA>  <tibble [100 x 3]>
> ## notice that the result is a nested tibble
> 
> draw(comp)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("confint.fderiv")
> ### * confint.fderiv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.fderiv
> ### Title: Point-wise and simultaneous confidence intervals for derivatives
> ###   of smooths
> ### Aliases: confint.fderiv
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 2, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> # new data to evaluate the derivatives at, say over the middle 50% of range
> # of each covariate
> middle <- function(x, n = 25, coverage = 0.5) {
+   v <- (1 - coverage) / 2
+   q <- quantile(x, prob = c(0 + v, 1 - v), type = 8)
+   seq(q[1], q[2], length = n)
+ }
> new_data <- sapply(dat[c("x0", "x1", "x2", "x3")], middle)
> new_data <- data.frame(new_data)
> ## first derivatives of all smooths...
> fd <- fderiv(mod, newdata = new_data)
Warning: `fderiv()` was deprecated in gratia 0.7.0.
i Please use `derivatives()` instead.
> 
> ## point-wise interval
> ci <- confint(fd, type = "confidence")
> ci
# A tibble: 100 x 4
   term    lower   est upper
   <chr>   <dbl> <dbl> <dbl>
 1 s(x0)  1.7     4.1    6.6
 2 s(x0)  1.3     3.8    6.3
 3 s(x0)  0.99    3.5    6.0
 4 s(x0)  0.68    3.1    5.6
 5 s(x0)  0.37    2.8    5.2
 6 s(x0)  0.0049  2.4    4.8
 7 s(x0) -0.40    2.0    4.5
 8 s(x0) -0.79    1.7    4.2
 9 s(x0) -1.1     1.3    3.8
10 s(x0) -1.4     0.99   3.4
# i 90 more rows
> 
> ## simultaneous interval for smooth term of x2
> ## Don't show: 
> set.seed(42)
> ## End(Don't show)
> x2_sint <- confint(fd, parm = "x2", type = "simultaneous",
+                    nsim = 10000, ncores = 2)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("confint.gam")
> ### * confint.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: confint.gam
> ### Title: Point-wise and simultaneous confidence intervals for smooths
> ### Aliases: confint.gam confint.gamm confint.list
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 2, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> # new data to evaluate the smooths at, say over the middle 50% of range
> # of each covariate
> middle <- function(x, n = 50, coverage = 0.5) {
+   v <- (1 - coverage) / 2
+   q <- quantile(x, prob = c(0 + v, 1 - v), type = 8)
+   seq(q[1], q[2], length = n)
+ }
> new_data <- sapply(dat[c("x0", "x1", "x2", "x3")], middle)
> new_data <- data.frame(new_data)
> 
> ## point-wise interval for smooth of x2
> ci <- confint(mod, parm = "s(x2)", type = "confidence", data = new_data)
> ci
# A tibble: 50 x 9
   smooth type  by       x2 .estimate   .se .crit .lower_ci .upper_ci
   <chr>  <chr> <chr> <dbl>     <dbl> <dbl> <dbl>     <dbl>     <dbl>
 1 s(x2)  TPRS  <NA>   0.26       5.3  0.18   2.0       5.0       5.7
 2 s(x2)  TPRS  <NA>   0.27       5.1  0.18   2.0       4.8       5.5
 3 s(x2)  TPRS  <NA>   0.28       4.9  0.18   2.0       4.6       5.3
 4 s(x2)  TPRS  <NA>   0.29       4.6  0.18   2.0       4.3       5.0
 5 s(x2)  TPRS  <NA>   0.30       4.3  0.19   2.0       3.9       4.7
 6 s(x2)  TPRS  <NA>   0.32       4.0  0.19   2.0       3.6       4.3
 7 s(x2)  TPRS  <NA>   0.33       3.6  0.20   2.0       3.2       4.0
 8 s(x2)  TPRS  <NA>   0.34       3.2  0.20   2.0       2.9       3.6
 9 s(x2)  TPRS  <NA>   0.35       2.9  0.20   2.0       2.5       3.3
10 s(x2)  TPRS  <NA>   0.36       2.5  0.19   2.0       2.1       2.9
# i 40 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("data_sim")
> ### * data_sim
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data_sim
> ### Title: Simulate example data for fitting GAMs
> ### Aliases: data_sim
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(pillar.sigfig = 5, cli.unicode = FALSE)
> ## End(Don't show)
> data_sim("eg1", n = 100, seed = 1)
# A tibble: 100 x 10
         y       x0      x1      x2       x3       f      f0     f1     f2    f3
     <dbl>    <dbl>   <dbl>   <dbl>    <dbl>   <dbl>   <dbl>  <dbl>  <dbl> <dbl>
 1 14.532  0.26551  0.65472 0.26751 0.67371  13.713  1.4814  3.7041 8.5277     0
 2 16.113  0.37212  0.35320 0.21865 0.094858 12.735  1.8408  2.0267 8.8680     0
 3  9.5835 0.57285  0.27026 0.51680 0.49260   6.4103 1.9478  1.7169 2.7456     0
 4 15.687  0.90821  0.99268 0.26895 0.46155  16.349  0.56879 7.2817 8.4980     0
 5  8.2216 0.20168  0.63349 0.18117 0.37522  12.792  1.1841  3.5501 8.0578     0
 6  9.9034 0.89839  0.21321 0.51858 0.99110   4.9081 0.62765 1.5318 2.7487     0
 7  5.9362 0.94468  0.12937 0.56278 0.17635   4.6020 0.34587 1.2953 2.9609     0
 8 10.839  0.66080  0.47812 0.12916 0.81344   9.7565 1.7502  2.6019 5.4045     0
 9 16.883  0.62911  0.92407 0.25637 0.068447 16.909  1.8377  6.3481 8.7237     0
10  7.3603 0.061786 0.59876 0.71794 0.40045   6.3401 0.38578 3.3119 2.6424     0
# i 90 more rows
> 
> # an ordered categorical response
> data_sim("eg1", n = 100, dist = "ocat", n_cat = 4, cuts = c(-1, 0, 5))
# A tibble: 100 x 11
       y       x0      x1      x2       x3        f      f0     f1     f2    f3
   <int>    <dbl>   <dbl>   <dbl>    <dbl>    <dbl>   <dbl>  <dbl>  <dbl> <dbl>
 1     4 0.26551  0.65472 0.26751 0.67371   4.9408  1.4814  3.7041 8.5277     0
 2     4 0.37212  0.35320 0.21865 0.094858  3.9631  1.8408  2.0267 8.8680     0
 3     1 0.57285  0.27026 0.51680 0.49260  -2.3620  1.9478  1.7169 2.7456     0
 4     4 0.90821  0.99268 0.26895 0.46155   7.5762  0.56879 7.2817 8.4980     0
 5     4 0.20168  0.63349 0.18117 0.37522   4.0197  1.1841  3.5501 8.0578     0
 6     2 0.89839  0.21321 0.51858 0.99110  -3.8642  0.62765 1.5318 2.7487     0
 7     1 0.94468  0.12937 0.56278 0.17635  -4.1703  0.34587 1.2953 2.9609     0
 8     3 0.66080  0.47812 0.12916 0.81344   0.98419 1.7502  2.6019 5.4045     0
 9     4 0.62911  0.92407 0.25637 0.068447  8.1371  1.8377  6.3481 8.7237     0
10     1 0.061786 0.59876 0.71794 0.40045  -2.4322  0.38578 3.3119 2.6424     0
# i 90 more rows
# i 1 more variable: latent <dbl>
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("data_slice")
> ### * data_slice
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data_slice
> ### Title: Prepare a data slice through model covariates
> ### Aliases: data_slice data_slice.default data_slice.data.frame
> ###   data_slice.gam data_slice.gamm data_slice.list data_slice.scam
> 
> ### ** Examples
> 
> load_mgcv()
> 
> # simulate some Gaussian data
> df <- data_sim("eg1", n = 50, seed = 2)
> 
> # fit a GAM with 1 smooth and 1 linear term
> m <- gam(y ~ s(x2, k = 7) + x1, data = df, method = "REML")
> 
> # Want to predict over f(x2) while holding `x1` at some value.
> # Default will use the observation closest to the median for unspecified
> # variables.
> ds <- data_slice(m, x2 = evenly(x2, n = 50))
> 
> # for full control, specify the values you want
> ds <- data_slice(m, x2 = evenly(x2, n = 50), x1 = 0.3)
> 
> # or provide an expression (function call) which will be evaluated in the
> # data frame passed to `data` or `model.frame(object)`
> ds <- data_slice(m, x2 = evenly(x2, n = 50), x1 = mean(x1))
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("derivative_samples")
> ### * derivative_samples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: derivative_samples
> ### Title: Posterior expectations of derivatives from an estimated model
> ### Aliases: derivative_samples derivative_samples.default
> ###   derivative_samples.gamm derivative_samples.gam
> 
> ### ** Examples
> 
> 
> load_mgcv()
> df <- data_sim("eg1", dist = "negbin", scale = 0.25, seed = 42)
> 
> # fit the GAM (note: for execution time reasons using bam())
> m <- bam(y ~ s(x0) + s(x1) + s(x2) + s(x3),
+     data = df, family = nb(), method = "fREML", discrete = TRUE)
> 
> # data slice through data along x2 - all other covariates will be set to
> # typical values (value closest to median)
> ds <- data_slice(m, x2 = evenly(x2, n = 200))
> 
> # samples from posterior of derivatives
> fd_samp <- derivative_samples(m, data = ds, type = "central",
+     focal = "x2", eps = 0.01, seed = 21, n_sim = 100)
> 
> # plot the first 20 posterior draws
> if (requireNamespace("ggplot2") && requireNamespace("dplyr")) {
+     library("ggplot2")
+     fd_samp |>
+         dplyr::filter(.draw <= 20) |>
+         ggplot(aes(x = x2, y = .derivative, group = .draw)) +
+         geom_line(alpha = 0.5)
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:mgcv’

> nameEx("derivatives")
> ### * derivatives
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: derivatives
> ### Title: Derivatives of estimated smooths via finite differences
> ### Aliases: derivatives derivatives.default derivatives.gamm
> ###   derivatives.gam
> 
> ### ** Examples
> 
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 42)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> ## first derivatives of all smooths using central finite differences
> derivatives(mod, type = "central")
# A tibble: 400 x 10
   smooth var   by_var fs_var     data derivative    se  crit lower upper
   <chr>  <chr> <chr>  <chr>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>
 1 s(x0)  x0    <NA>   <NA>   0.000239       7.41  3.33  1.96 0.874  13.9
 2 s(x0)  x0    <NA>   <NA>   0.0103         7.40  3.33  1.96 0.884  13.9
 3 s(x0)  x0    <NA>   <NA>   0.0204         7.39  3.30  1.96 0.929  13.8
 4 s(x0)  x0    <NA>   <NA>   0.0304         7.36  3.24  1.96 1.01   13.7
 5 s(x0)  x0    <NA>   <NA>   0.0405         7.32  3.15  1.96 1.14   13.5
 6 s(x0)  x0    <NA>   <NA>   0.0506         7.26  3.04  1.96 1.30   13.2
 7 s(x0)  x0    <NA>   <NA>   0.0606         7.18  2.90  1.96 1.49   12.9
 8 s(x0)  x0    <NA>   <NA>   0.0707         7.09  2.76  1.96 1.69   12.5
 9 s(x0)  x0    <NA>   <NA>   0.0807         6.99  2.61  1.96 1.87   12.1
10 s(x0)  x0    <NA>   <NA>   0.0908         6.87  2.47  1.96 2.03   11.7
# i 390 more rows
> 
> ## derivatives for a selected smooth
> derivatives(mod, type = "central", term = "s(x1)")
# A tibble: 100 x 10
   smooth var   by_var fs_var     data derivative    se  crit lower upper
   <chr>  <chr> <chr>  <chr>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>
 1 s(x1)  x1    <NA>   <NA>   0.000405     -0.907  3.12  1.96 -7.02  5.20
 2 s(x1)  x1    <NA>   <NA>   0.0105       -0.906  3.11  1.96 -7.01  5.20
 3 s(x1)  x1    <NA>   <NA>   0.0205       -0.898  3.10  1.96 -6.97  5.17
 4 s(x1)  x1    <NA>   <NA>   0.0306       -0.880  3.06  1.96 -6.88  5.12
 5 s(x1)  x1    <NA>   <NA>   0.0406       -0.849  3.00  1.96 -6.73  5.03
 6 s(x1)  x1    <NA>   <NA>   0.0507       -0.803  2.92  1.96 -6.52  4.92
 7 s(x1)  x1    <NA>   <NA>   0.0607       -0.740  2.81  1.96 -6.25  4.77
 8 s(x1)  x1    <NA>   <NA>   0.0708       -0.659  2.69  1.96 -5.93  4.61
 9 s(x1)  x1    <NA>   <NA>   0.0809       -0.557  2.56  1.96 -5.57  4.46
10 s(x1)  x1    <NA>   <NA>   0.0909       -0.436  2.42  1.96 -5.19  4.32
# i 90 more rows
> ## or via a partial match
> derivatives(mod, type = "central", term = "x1", partial_match = TRUE)
# A tibble: 100 x 10
   smooth var   by_var fs_var     data derivative    se  crit lower upper
   <chr>  <chr> <chr>  <chr>     <dbl>      <dbl> <dbl> <dbl> <dbl> <dbl>
 1 s(x1)  x1    <NA>   <NA>   0.000405     -0.907  3.12  1.96 -7.02  5.20
 2 s(x1)  x1    <NA>   <NA>   0.0105       -0.906  3.11  1.96 -7.01  5.20
 3 s(x1)  x1    <NA>   <NA>   0.0205       -0.898  3.10  1.96 -6.97  5.17
 4 s(x1)  x1    <NA>   <NA>   0.0306       -0.880  3.06  1.96 -6.88  5.12
 5 s(x1)  x1    <NA>   <NA>   0.0406       -0.849  3.00  1.96 -6.73  5.03
 6 s(x1)  x1    <NA>   <NA>   0.0507       -0.803  2.92  1.96 -6.52  4.92
 7 s(x1)  x1    <NA>   <NA>   0.0607       -0.740  2.81  1.96 -6.25  4.77
 8 s(x1)  x1    <NA>   <NA>   0.0708       -0.659  2.69  1.96 -5.93  4.61
 9 s(x1)  x1    <NA>   <NA>   0.0809       -0.557  2.56  1.96 -5.57  4.46
10 s(x1)  x1    <NA>   <NA>   0.0909       -0.436  2.42  1.96 -5.19  4.32
# i 90 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("difference_smooths")
> ### * difference_smooths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: difference_smooths
> ### Title: Differences of factor smooth interactions
> ### Aliases: difference_smooths difference_smooths.gam
> 
> ### ** Examples
> 
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg4", seed = 42)
> m <- gam(y ~ fac + s(x2, by = fac) + s(x0), data = df, method = "REML")
> 
> sm_dif <- difference_smooths(m, smooth = "s(x2)")
> sm_dif
# A tibble: 300 x 9
   smooth by    level_1 level_2  diff    se    lower upper      x2
   <chr>  <chr> <chr>   <chr>   <dbl> <dbl>    <dbl> <dbl>   <dbl>
 1 s(x2)  fac   1       2       0.386 0.618 -0.824    1.60 0.00359
 2 s(x2)  fac   1       2       0.479 0.574 -0.646    1.60 0.0136 
 3 s(x2)  fac   1       2       0.572 0.534 -0.474    1.62 0.0237 
 4 s(x2)  fac   1       2       0.665 0.497 -0.308    1.64 0.0338 
 5 s(x2)  fac   1       2       0.758 0.464 -0.151    1.67 0.0438 
 6 s(x2)  fac   1       2       0.850 0.435 -0.00342  1.70 0.0539 
 7 s(x2)  fac   1       2       0.941 0.412  0.134    1.75 0.0639 
 8 s(x2)  fac   1       2       1.03  0.393  0.262    1.80 0.0740 
 9 s(x2)  fac   1       2       1.12  0.378  0.380    1.86 0.0841 
10 s(x2)  fac   1       2       1.21  0.367  0.489    1.93 0.0941 
# i 290 more rows
> 
> draw(sm_dif)
> 
> # include the groups means for `fac` in the difference
> sm_dif2 <- difference_smooths(m, smooth = "s(x2)", group_means = TRUE)
> draw(sm_dif2)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.basis")
> ### * draw.basis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.basis
> ### Title: Plot basis functions
> ### Aliases: draw.basis
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", n = 400, seed = 42)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> bf <- basis(m)
> draw(bf)
> 
> bf <- basis(m, "s(x2)")
> draw(bf)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.derivatives")
> ### * draw.derivatives
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.derivatives
> ### Title: Plot derivatives of smooths
> ### Aliases: draw.derivatives draw.partial_derivatives
> 
> ### ** Examples
> 
> 
> load_mgcv()
> dat <- data_sim("eg1", n = 800, dist = "normal", scale = 2, seed = 42)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> ## first derivative of all smooths
> df <- derivatives(mod, type = "central")
> draw(df)
> ## fixed axis scales
> draw(df, scales = "fixed")
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.difference_smooth")
> ### * draw.difference_smooth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.difference_smooth
> ### Title: Plot differences of smooths
> ### Aliases: draw.difference_smooth
> 
> ### ** Examples
> 
> 
> load_mgcv()
> # simulate some data; a factor smooth example
> df <- data_sim("eg4", seed = 42)
> # fit GAM
> m <- gam(y ~ fac + s(x2, by = fac) + s(x0), data = df, method = "REML")
> 
> # calculate the differences between pairs of smooths the f_j(x2) term
> diffs <- difference_smooths(m, smooth = "s(x2)")
> draw(diffs)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.evaluated_smooth")
> ### * draw.evaluated_smooth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.evaluated_smooth
> ### Title: Plot estimated smooths
> ### Aliases: draw.evaluated_smooth draw.evaluated_1d_smooth
> ###   draw.evaluated_2d_smooth geom_rug draw.evaluated_re_smooth
> ###   draw.evaluated_fs_smooth draw.evaluated_parametric_term
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(cli.unicode = FALSE)
> ## End(Don't show)
> load_mgcv()
> 
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> sm <- evaluate_smooth(m1, "s(x2)")
Warning: `evaluate_smooth()` was deprecated in gratia 0.7.0.
i Please use `smooth_estimates()` instead.
> draw(sm)
> 
> ## supply constant to shift y axis scale
> draw(sm, constant = coef(m1)[1])
> 
> dat <- data_sim("eg2", n = 1000, dist = "normal", scale = 1, seed = 2)
> m2 <- gam(y ~ s(x, z, k = 40), data = dat, method = "REML")
> 
> sm <- evaluate_smooth(m2, "s(x,z)", n = 100)
> draw(sm)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.gam")
> ### * draw.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.gam
> ### Title: Plot estimated smooths from a fitted GAM
> ### Aliases: draw.gam
> 
> ### ** Examples
> 
> load_mgcv()
> 
> # simulate some data
> df1 <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> # fit GAM
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df1, method = "REML")
> 
> # plot all smooths
> draw(m1)
> 
> # can add partial residuals
> draw(m1, residuals = TRUE)
> 
> df2 <- data_sim(2, n = 1000, dist = "normal", scale = 1, seed = 2)
> m2 <- gam(y ~ s(x, z, k = 40), data = df2, method = "REML")
> draw(m2, contour = FALSE, n = 50)
> 
> # change the number of contours drawn and the fill scale used for
> # the surface
> library("ggplot2")
> draw(m2, n_contour = 5, n = 50,
+      continuous_fill = scale_fill_distiller(palette = "Spectral",
+                                             type = "div"))
> 
> # See https://gavinsimpson.github.io/gratia/articles/custom-plotting.html
> # for more examples and for details on how to modify the theme of all the
> # plots produced by draw(). To modify all panels, for example to change the
> # theme, use the & operator
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’, ‘package:mgcv’

> nameEx("draw.gamlss")
> ### * draw.gamlss
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.gamlss
> ### Title: Plot smooths of a GAMLSS model estimated by 'GJRM::gamlss'
> ### Aliases: draw.gamlss
> 
> ### ** Examples
> 
> if (require("GJRM", quietly = TRUE)) {
+     # follow example from ?GJRM::gamlss
+     load_mgcv()
+     suppressPackageStartupMessages(library("GJRM"))
+     set.seed(0)
+     n <- 100
+     x1 <- round(runif(n))
+     x2 <- runif(n)
+     x3 <- runif(n)
+     f1 <- function(x) cos(pi*2*x) + sin(pi*x)
+     y1 <- -1.55 + 2*x1 + f1(x2) + rnorm(n)
+     dataSim <- data.frame(y1, x1, x2, x3)
+ 
+     eq_mu <- y1 ~ x1 + s(x2)
+     eq_s  <-    ~ s(x3, k = 6)
+     fl    <- list(eq_mu, eq_s)
+     m <- gamlss(fl, data = dataSim)
+ 
+     draw(m)
+ }
This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.

This is GJRM 0.2-6.4.
For overview type 'help("GJRM-package")'.

> 
> 
> 
> cleanEx()

detaching ‘package:GJRM’, ‘package:mgcv’, ‘package:nlme’

> nameEx("draw.mgcv_smooth")
> ### * draw.mgcv_smooth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.mgcv_smooth
> ### Title: Plot basis functions
> ### Aliases: draw.mgcv_smooth
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg4", n = 400, seed = 42)
> 
> bf <- basis(s(x0), data = df)
> draw(bf)
> 
> bf <- basis(s(x2, by = fac, bs = "bs"), data = df)
> draw(bf)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.penalty_df")
> ### * draw.penalty_df
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.penalty_df
> ### Title: Display penalty matrices of smooths using 'ggplot'
> ### Aliases: draw.penalty_df
> 
> ### ** Examples
> 
> load_mgcv()
> dat <- data_sim("eg4", n = 400, seed = 42)
> m <- gam(y ~ s(x0) + s(x1, bs = 'cr') + s(x2, bs = 'bs', by = fac),
+          data = dat, method = "REML")
> 
> ## produce a multi-panel plot of all penalties
> draw(penalty(m))
> 
> # for a specific smooth
> draw(penalty(m, smooth = "s(x2):fac1"))
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.rootogram")
> ### * draw.rootogram
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.rootogram
> ### Title: Draw a rootogram
> ### Aliases: draw.rootogram
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", n = 1000, dist = "poisson", scale = 0.1, seed = 6)
> 
> # A poisson example
> m <- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") + s(x2, bs = "cr") +
+          s(x3, bs = "cr"), family = poisson(), data = df, method = "REML")
> rg <- rootogram(m)
> 
> # plot the rootogram
> draw(rg)
> 
> # change the type of rootogram
> draw(rg, type = "suspended")
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.smooth_estimates")
> ### * draw.smooth_estimates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.smooth_estimates
> ### Title: Plot the result of a call to 'smooth_estimates()'
> ### Aliases: draw.smooth_estimates
> 
> ### ** Examples
> 
> load_mgcv()
> # example data
> df <- data_sim("eg1", seed = 21)
> # fit GAM
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> # plot all of the estimated smooths
> sm <- smooth_estimates(m)
> draw(sm)
> # evaluate smooth of `x2`
> sm <- smooth_estimates(m, smooth = "s(x2)")
> # plot it
> draw(sm)
> 
> # customising some plot elements
> draw(sm, ci_col = "steelblue", smooth_col = "forestgreen", ci_alpha = 0.3)
> 
> # Add a constant to the plotted smooth
> draw(sm, constant = coef(m)[1])
> 
> # Adding change indicators to smooths based on derivatives of the smooth
> d <- derivatives(m, n = 100) # n to match smooth_estimates()
> 
> smooth_estimates(m) |>
+     add_sizer(derivatives = d, type = "sizer") |>
+     draw()
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("draw.smooth_samples")
> ### * draw.smooth_samples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw.smooth_samples
> ### Title: Plot posterior smooths
> ### Aliases: draw.smooth_samples
> 
> ### ** Examples
> 
> load_mgcv()
> dat1 <- data_sim("eg1", n = 400, dist = "normal", scale = 1, seed = 1)
> ## a single smooth GAM
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat1, method = "REML")
> ## posterior smooths from m1
> sm1 <- smooth_samples(m1, n = 15, seed = 23478)
> ## plot
> draw(sm1, alpha = 0.7)
> ## plot only 5 randomly smapled draws
> draw(sm1, n_samples = 5, alpha = 0.7)
> 
> ## A factor-by smooth example
> dat2 <- data_sim("eg4", n = 400, dist = "normal", scale = 1, seed = 1)
> ## a multi-smooth GAM with a factor-by smooth
> m2 <- gam(y ~ fac + s(x2, by = fac) + s(x0), data = dat2, method = "REML")
> ## posterior smooths from m1
> sm2 <- smooth_samples(m2, n = 15, seed = 23478)
> ## plot, this time selecting only the factor-by smooth
> draw(sm2, select = "s(x2)", partial_match = TRUE, alpha = 0.7)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("edf")
> ### * edf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edf
> ### Title: Effective degrees of freedom for smooths and GAMs
> ### Aliases: edf edf.gam model_edf
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 5)
> ## End(Don't show)
> df <- data_sim("eg1", n = 400, seed = 42)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> # extract the EDFs for all smooths
> edf(m)
# A tibble: 4 x 2
  smooth    edf
  <chr>   <dbl>
1 s(x0)  3.4248
2 s(x1)  3.2213
3 s(x2)  7.9049
4 s(x3)  1.8847
> 
> # or selected smooths
> edf(m, smooth = c("s(x0)", "s(x2)"))
# A tibble: 2 x 2
  smooth    edf
  <chr>   <dbl>
1 s(x0)  3.4248
2 s(x2)  7.9049
> 
> # accounting for smoothness parameter uncertainty
> edf(m, type = "unconditional")
# A tibble: 4 x 2
  smooth    edf
  <chr>   <dbl>
1 s(x0)  3.7697
2 s(x1)  3.8728
3 s(x2)  8.0670
4 s(x3)  2.8834
> 
> # over EDF of the model, including the intercept
> model_edf(m)
# A tibble: 1 x 2
  model    edf
  <chr>  <dbl>
1 m     17.436
> 
> # can get model EDF for multiple models
> m2 <- gam(y ~ s(x0) + s(x1) + s(x3), data = df, method = "REML")
> model_edf(m, m2)
# A tibble: 2 x 2
  model     edf
  <chr>   <dbl>
1 m     17.436 
2 m2     7.5777
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("evaluate_smooth")
> ### * evaluate_smooth
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: evaluate_smooth
> ### Title: Evaluate a smooth
> ### Aliases: evaluate_smooth evaluate_smooth.gam evaluate_smooth.gamm
> ###   evaluate_smooth.list
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 2)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 500, dist = "normal", scale = 1, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> evaluate_smooth(m1, "s(x1)")
# A tibble: 100 x 5
   smooth by_variable     x1   est    se
   <chr>  <fct>        <dbl> <dbl> <dbl>
 1 s(x1)  <NA>        0.0025  -2.1 0.17 
 2 s(x1)  <NA>        0.013   -2.1 0.15 
 3 s(x1)  <NA>        0.023   -2.1 0.14 
 4 s(x1)  <NA>        0.033   -2.0 0.13 
 5 s(x1)  <NA>        0.043   -2.0 0.12 
 6 s(x1)  <NA>        0.053   -2.0 0.11 
 7 s(x1)  <NA>        0.063   -2.0 0.11 
 8 s(x1)  <NA>        0.073   -2.0 0.10 
 9 s(x1)  <NA>        0.083   -2.0 0.10 
10 s(x1)  <NA>        0.093   -2.0 0.097
# i 90 more rows
> 
> ## 2d example
> dat <- data_sim("eg2", n = 1000, dist = "normal", scale = 1, seed = 2)
> m2 <- gam(y ~ s(x, z, k = 30), data = dat, method = "REML")
> 
> evaluate_smooth(m2, "s(x,z)", n = 50)
# A tibble: 2,500 x 6
   smooth by_variable       x       z   est    se
   <chr>  <fct>         <dbl>   <dbl> <dbl> <dbl>
 1 s(x,z) <NA>        0.00066 0.00076 0.088  0.19
 2 s(x,z) <NA>        0.021   0.00076 0.097  0.18
 3 s(x,z) <NA>        0.041   0.00076 0.11   0.18
 4 s(x,z) <NA>        0.062   0.00076 0.12   0.17
 5 s(x,z) <NA>        0.082   0.00076 0.13   0.16
 6 s(x,z) <NA>        0.10    0.00076 0.14   0.16
 7 s(x,z) <NA>        0.12    0.00076 0.14   0.15
 8 s(x,z) <NA>        0.14    0.00076 0.15   0.15
 9 s(x,z) <NA>        0.16    0.00076 0.16   0.14
10 s(x,z) <NA>        0.18    0.00076 0.17   0.14
# i 2,490 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("evenly")
> ### * evenly
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: evenly
> ### Title: Create a sequence of evenly-spaced values
> ### Aliases: evenly seq_min_max
> 
> ### ** Examples
> 
> ## Don't show: 
> set.seed(1)
> ## End(Don't show)
> x <- rnorm(10)
> n <- 10L
> 
> # 10 values evenly over the range of `x`
> evenly(x, n = n)
 [1] -0.83562861 -0.56552757 -0.29542652 -0.02532547  0.24477557  0.51487662
 [7]  0.78497766  1.05507871  1.32517976  1.59528080
> 
> # evenly spaced values, incrementing by 0.2
> evenly(x, by = 0.2)
 [1] -0.83562861 -0.63562861 -0.43562861 -0.23562861 -0.03562861  0.16437139
 [7]  0.36437139  0.56437139  0.76437139  0.96437139  1.16437139  1.36437139
[13]  1.56437139
> 
> # evenly spaced values, incrementing by 0.2, starting at -2
> evenly(x, by = 0.2, lower = -2)
 [1] -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 -0.6 -0.4 -0.2  0.0  0.2  0.4  0.6  0.8
[16]  1.0  1.2  1.4
> 
> 
> 
> cleanEx()
> nameEx("fderiv")
> ### * fderiv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fderiv
> ### Title: First derivatives of fitted GAM functions
> ### Aliases: fderiv fderiv.gam fderiv.gamm
> ### Keywords: internal
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(lifecycle_verbosity = "quiet")
> ## End(Don't show)
> dat <- data_sim("eg1", seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> ## first derivatives of all smooths...
> fd <- fderiv(mod)
> ## now use -->
> fd <- derivatives(mod)
> 
> ## ...and a selected smooth
> fd2 <- fderiv(mod, term = "x1")
> ## now use -->
> fd2 <- derivatives(mod, term = "s(x1)")
> 
> ## Models with factors
> dat <- data_sim("eg4", n = 400, dist = "normal", scale = 2, seed = 2)
> mod <- gam(y ~ s(x0) + s(x1) + fac, data = dat, method = "REML")
> 
> ## first derivatives of all smooths...
> fd <- fderiv(mod)
> ## now use -->
> fd <- derivatives(mod)
> 
> ## ...and a selected smooth
> fd2 <- fderiv(mod, term = "x1")
> ## now use -->
> fd2 <- derivatives(mod, term = "s(x1)")
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("fitted_samples")
> ### * fitted_samples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitted_samples
> ### Title: Draw fitted values from the posterior distribution
> ### Aliases: fitted_samples fitted_samples.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> fs <- fitted_samples(m1, n = 5, seed = 42)
> 
> # can generate own set of draws and use them
> drws <- generate_draws(m1, n = 2, seed = 24)
> fs2 <- fitted_samples(m1, method = "user", draws = drws)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("fitted_values")
> ### * fitted_values
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitted_values
> ### Title: Generate fitted values from a estimated GAM
> ### Aliases: fitted_values fitted_values.gam fitted_values.gamm
> ###   fitted_values.scam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 6)
> ## End(Don't show)
> sim_df <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = sim_df, method = "REML")
> fv <- fitted_values(m)
> fv
# A tibble: 400 x 9
    .row       x0        x1         x2       x3  .fitted      .se .lower_ci
   <int>    <dbl>     <dbl>      <dbl>    <dbl>    <dbl>    <dbl>     <dbl>
 1     1 0.184882 0.617142  0.415244   0.132410  8.73875 0.354677   8.04360
 2     2 0.702374 0.569064  0.531439   0.365331  7.62581 0.337779   6.96378
 3     3 0.573326 0.153970  0.00324621 0.454532  3.12106 0.591862   1.96103
 4     4 0.168052 0.0348332 0.252100   0.537114 11.1124  0.402378  10.3237 
 5     5 0.943839 0.997953  0.155229   0.185495 14.0533  0.452947  13.1655 
 6     6 0.943475 0.835574  0.878840   0.449276  6.13080 0.364521   5.41635
 7     7 0.129159 0.586562  0.203511   0.256527 12.4838  0.355808  11.7864 
 8     8 0.833449 0.339117  0.583528   0.618458  6.25215 0.344700   5.57655
 9     9 0.468019 0.166883  0.804473   0.880744  4.21463 0.372003   3.48552
10    10 0.549984 0.807410  0.264717   0.317747 15.5283  0.369999  14.8031 
# i 390 more rows
# i 1 more variable: .upper_ci <dbl>
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("fix_offset")
> ### * fix_offset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fix_offset
> ### Title: Fix the names of a data frame containing an offset variable.
> ### Aliases: fix_offset
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> set.seed(2)
> ## End(Don't show)
> df <- data_sim("eg1", n = 400, dist = "normal", seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + offset(x2), data = df, method = "REML")
> names(model.frame(m))
[1] "y"          "offset(x2)" "x0"         "x1"        
> names(fix_offset(m, model.frame(m), offset_val = 1L))
[1] "y"  "x2" "x0" "x1"
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("fixef.gam")
> ### * fixef.gam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fixef.gam
> ### Title: Extract fixed effects estimates from a fitted GAM
> ### Aliases: fixef.gam fixef.gamm fixef.lm fixef.glm fixed_effects
> ###   fixed_effects.default
> 
> ### ** Examples
> 
> load_mgcv()
> 
> # run example if lme4 is available
> if (require("lme4")) {
+ 
+ data(sleepstudy, package = "lme4")
+ m <- gam(Reaction ~ Days + s(Subject, bs = "re") +
+            s(Days, Subject, bs = "re"),
+          data = sleepstudy, method = "REML")
+ fixef(m)
+ 
+ }
Loading required package: lme4
Loading required package: Matrix
(Intercept)        Days 
  251.40510    10.46729 
> 
> 
> 
> cleanEx()

detaching ‘package:lme4’, ‘package:Matrix’, ‘package:mgcv’

> nameEx("gw_functions")
> ### * gw_functions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gw_f0
> ### Title: Gu and Wabha test functions
> ### Aliases: gw_f0 gw_f1 gw_f2 gw_f3
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(digits = 4)
> ## End(Don't show)
> x <- seq(0, 1, length = 6)
> gw_f0(x)
[1] 0.000e+00 1.176e+00 1.902e+00 1.902e+00 1.176e+00 2.449e-16
> gw_f1(x)
[1] 1.000 1.492 2.226 3.320 4.953 7.389
> gw_f2(x)
[1] 0.000 8.591 4.261 3.199 1.100 0.000
> gw_f3(x) # should be constant 0
[1] 0 0 0 0 0 0
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("has_theta")
> ### * has_theta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: has_theta
> ### Title: Are additional parameters available for a GAM?
> ### Aliases: has_theta
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", dist = "poisson", seed = 42, scale = 1/5)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML",
+          family = nb())
> has_theta(m)
[1] TRUE
> p <- theta(m)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("is_offset")
> ### * is_offset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_offset
> ### Title: Is a model term an offset?
> ### Aliases: is_offset
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", n = 400, dist = "normal")
> m <- gam(y ~ s(x0) + s(x1) + offset(x0), data = df, method = "REML")
> nm <- names(model.frame(m))
> nm
[1] "y"          "offset(x0)" "x0"         "x1"        
> is_offset(nm)
[1] FALSE  TRUE FALSE FALSE
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("link")
> ### * link
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: link
> ### Title: Extract link and inverse link functions from models
> ### Aliases: link link.family link.gam link.bam link.gamm link.glm
> ###   link.list inv_link inv_link.family inv_link.gam inv_link.bam
> ###   inv_link.gamm inv_link.list inv_link.glm extract_link
> ###   extract_link.family extract_link.general.family
> 
> ### ** Examples
> 
> load_mgcv()
> 
> link(gaussian())
function (mu) 
mu
<environment: namespace:stats>
> link(nb())
function (mu) 
log(mu)
<environment: namespace:stats>
> 
> inv_link(nb())
function (eta) 
pmax(exp(eta), .Machine$double.eps)
<environment: namespace:stats>
> 
> dat <- data_sim("eg1", seed = 4234)
> mod <- gam(list(y ~ s(x0) + s(x1) + s(x2) + s(x3), ~ 1), data = dat,
+            family = gaulss)
> 
> link(mod, parameter = "scale")
function (mu) 
log(1/mu - 0.01)
<environment: 0x55f843048450>
> inv_link(mod, parameter = "scale")
function (eta) 
1/(exp(eta) + 0.01)
<environment: 0x55f843048450>
> 
> ## Works with `family` objects too
> link(shash(), parameter = "skewness")
function (mu) 
mu
<environment: namespace:stats>
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("lp_matrix")
> ### * lp_matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lp_matrix
> ### Title: Return the linear prediction matrix of a fitted GAM
> ### Aliases: lp_matrix lp_matrix.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", seed = 1)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df)
> 
> # linear prediction matrix for observed data
> xp <- lp_matrix(m)
> ## IGNORE_RDIFF_BEGIN
> xp
Linear prediction matrix (400 x 37)
  `(Intercept)` `s(x0).1` `s(x0).2` `s(x0).3` `s(x0).4` `s(x0).5` `s(x0).6`
          <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>
1             1     0.961     0.227    0.706      0.135     0.457  -0.146  
2             1     0.651    -0.241    0.0684     0.308     0.394  -0.00994
3             1    -0.385    -0.549    0.0660     0.204    -0.416  -0.247  
4             1    -1.27      0.156   -1.53      -0.222    -1.60    0.198  
5             1     1.05      0.420    1.11      -0.214     0.893   0.0351 
# i 395 more rows
> ## IGNORE_RDIFF_END
> 
> # the object `xp` *is* a matrix
> class(xp)
[1] "lp_matrix" "matrix"    "array"    
> # but we print like a tibble to avoid spamming the R console
> 
> # linear predictor matrix for new data set
> ds <- data_slice(m, x2 = evenly(x2))
> xp <- lp_matrix(m, data = ds)
> ## IGNORE_RDIFF_BEGIN
> xp
Linear prediction matrix (100 x 37)
  `(Intercept)` `s(x0).1` `s(x0).2` `s(x0).3` `s(x0).4` `s(x0).5` `s(x0).6`
          <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>
1             1     0.170    -0.542   -0.0371    0.0534     0.144    -0.353
2             1     0.170    -0.542   -0.0371    0.0534     0.144    -0.353
3             1     0.170    -0.542   -0.0371    0.0534     0.144    -0.353
4             1     0.170    -0.542   -0.0371    0.0534     0.144    -0.353
5             1     0.170    -0.542   -0.0371    0.0534     0.144    -0.353
# i 95 more rows
> ## IGNORE_RDIFF_END
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("model_concurvity")
> ### * model_concurvity
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model_concurvity
> ### Title: Concurvity of an estimated GAM
> ### Aliases: model_concurvity model_concurvity.gam concrvity
> 
> ### ** Examples
> 
> ## simulate data with concurvity...
> library("tibble")
> load_mgcv()
> set.seed(8)
> n <- 200
> df <- tibble(t = sort(runif(n)),
+              x = gw_f2(t) + rnorm(n) * 3,
+              y = sin(4 * pi * t) + exp(x / 20) + rnorm(n) * 0.3)
> 
> ## fit model
> m <- gam(y ~ s(t, k = 15) + s(x, k = 15), data = df, method = "REML")
> 
> ## overall concurvity
> o_conc <- concrvity(m)
> draw(o_conc)
> 
> ## pairwise concurvity
> p_conc <- concrvity(m, pairwise = TRUE)
> draw(p_conc)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’, ‘package:tibble’

> nameEx("model_vars")
> ### * model_vars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: model_vars
> ### Title: List the variables involved in a model fitted with a formula
> ### Aliases: model_vars model_vars.gam model_vars.default model_vars.bam
> ###   model_vars.gamm model_vars.gamm4 model_vars.list
> 
> ### ** Examples
> 
> load_mgcv()
> 
> # simulate some Gaussian data
> df <- data_sim("eg1", n = 50, seed = 2)
> 
> # fit a GAM with 1 smooth and 1 linear term
> m1 <- gam(y ~ s(x2, k = 7) + x1, data = df, method = "REML")
> model_vars(m1)
[1] "x1" "x2"
> 
> # fit a lm with two linear terms
> m2 <- lm(y ~ x2 + x1, data = df)
> model_vars(m2)
[1] "x2" "x1"
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("nb_theta")
> ### * nb_theta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nb_theta
> ### Title: Negative binomial parameter theta
> ### Aliases: nb_theta nb_theta.gam
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", n = 500, dist = "poisson", scale = 0.1, seed = 6)
> 
> m <- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") + s(x2, bs = "cr") +
+          s(x3, bs = "cr"), family = nb, data = df, method = "REML")
> ## IGNORE_RDIFF_BEGIN
> nb_theta(m)
[1] 239349
> ## IGNORE_RDIFF_END
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("overview")
> ### * overview
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: overview
> ### Title: Provides an overview of a model and the terms in that model
> ### Aliases: overview overview.gam
> 
> ### ** Examples
> 
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim(n = 400, seed = 2)
> m <- gam(y ~ x3 + s(x0) + s(x1, bs = "bs") + s(x2, bs = "ts"),
+          data = df, method = "REML")
> overview(m)

Generalized Additive Model with 4 terms

  term  type              k   edf statistic p.value
  <chr> <chr>         <dbl> <dbl>     <dbl> <chr>  
1 x3    parametric       NA  1         4.28 0.03926
2 s(x0) TPRS              9  3.02      6.25 < 0.001
3 s(x1) B spline          9  2.81     71.0  < 0.001
4 s(x2) TPRS (shrink)     9  7.91     83.8  < 0.001
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("partial_derivatives")
> ### * partial_derivatives
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: partial_derivatives
> ### Title: Partial derivatives of estimated multivariate smooths via finite
> ###   differences
> ### Aliases: partial_derivatives partial_derivatives.default
> ###   partial_derivatives.gamm partial_derivatives.gam
> 
> ### ** Examples
> 
> 
> library("ggplot2")
> library("patchwork")
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg2", n = 2000, dist = "normal", scale = 0.5, seed = 42)
> 
> # fit the GAM (note: for execution time reasons, k is set articifially low)
> m <- gam(y ~ te(x, z, k = c(5, 5)), data = df, method = "REML")
> 
> # data slice through te(x,z) holding z == 0.4
> ds <- data_slice(m, x = evenly(x, n = 100), z = 0.4)
> 
> # evaluate te(x,z) at values of x & z
> sm <- smooth_estimates(m, smooth = "te(x,z)", data = ds) |>
+     add_confint()
> 
> # partial derivatives
> pd_x <- partial_derivatives(m, data = ds, type = "central", focal = "x")
> 
> # draw te(x,z)
> p1 <- draw(m, rug = FALSE) &
+     geom_hline(yintercept = 0.4, linewidth = 1)
> p1
> 
> # draw te(x,z) along slice
> cap <- expression(z == 0.4)
> p2 <- sm |>
+     ggplot(aes(x = x, y = .estimate)) +
+     geom_ribbon(aes(ymin = .lower_ci, ymax = .upper_ci), alpha = 0.2) +
+     geom_line() +
+     labs(x = "x", y = "Partial effect", title = "te(x,z)",
+         caption = cap)
> p2
> 
> # draw partial derivs
> p3 <- pd_x |>
+     draw() +
+     labs(caption = cap)
> p3
> 
> # draw all three panels
> p1 + p2 + p3 + plot_layout(ncol = 3)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’, ‘package:patchwork’, ‘package:ggplot2’

> nameEx("partial_residuals")
> ### * partial_residuals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: partial_residuals
> ### Title: Partial residuals
> ### Aliases: partial_residuals partial_residuals.gam
> 
> ### ** Examples
> 
> ## Don't show: 
> set.seed(1)
> op <- options(pillar.sigfig = 4, cli.unicode = FALSE)
> ## End(Don't show)
> ## load mgcv
> load_mgcv()
> 
> ## example data - Gu & Wabha four term model
> df <- data_sim("eg1", n = 400, seed = 42)
> ## fit the model
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = 'REML')
> 
> ## extract partial residuals
> partial_residuals(m)
# A tibble: 400 x 4
   `s(x0)`  `s(x1)` `s(x2)`  `s(x3)`
     <dbl>    <dbl>   <dbl>    <dbl>
 1 -0.3527 -1.321   -2.180   0.6077 
 2 -0.1233  0.5013  -1.775   0.9613 
 3  1.429   1.515    5.609   0.9910 
 4 -1.110  -1.700   -0.8882 -0.6593 
 5 -2.120  -0.01378 -2.733  -3.012  
 6  1.254  -1.224    3.915   0.07275
 7 -0.5220  3.023   -0.8197 -1.019  
 8  1.398   0.2184   7.055   1.897  
 9  2.797   0.4969   7.329   2.498  
10  1.151  -0.2267   0.7202  0.7437 
# i 390 more rows
> 
> ## and for a select term
> partial_residuals(m, select = "s(x2)")
# A tibble: 400 x 1
   `s(x2)`
     <dbl>
 1 -2.180 
 2 -1.775 
 3  5.609 
 4 -0.8882
 5 -2.733 
 6  3.915 
 7 -0.8197
 8  7.055 
 9  7.329 
10  0.7202
# i 390 more rows
> 
> ## or with partial matching
> partial_residuals(m, select = "x", partial_match = TRUE) # returns all
# A tibble: 400 x 4
   `s(x0)`  `s(x1)` `s(x2)`  `s(x3)`
     <dbl>    <dbl>   <dbl>    <dbl>
 1 -0.3527 -1.321   -2.180   0.6077 
 2 -0.1233  0.5013  -1.775   0.9613 
 3  1.429   1.515    5.609   0.9910 
 4 -1.110  -1.700   -0.8882 -0.6593 
 5 -2.120  -0.01378 -2.733  -3.012  
 6  1.254  -1.224    3.915   0.07275
 7 -0.5220  3.023   -0.8197 -1.019  
 8  1.398   0.2184   7.055   1.897  
 9  2.797   0.4969   7.329   2.498  
10  1.151  -0.2267   0.7202  0.7437 
# i 390 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("penalty")
> ### * penalty
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: penalty
> ### Title: Extract and tidy penalty matrices
> ### Aliases: penalty penalty.gam penalty.mgcv.smooth penalty.tensor.smooth
> ###   penalty.t2.smooth penalty.re.smooth.spec
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 3)
> ## End(Don't show)
> load_mgcv()
> dat <- data_sim("eg4", n = 400, seed = 42)
> m <- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") +
+            s(x2, by = fac, bs = "cr"),
+          data = dat, method = "REML")
> 
> # penalties for all smooths
> penalty(m)
# A tibble: 405 x 6
   smooth type  penalty row   col     value
   <chr>  <chr> <chr>   <chr> <chr>   <dbl>
 1 s(x0)  CRS   s(x0)   F1    F1     0.783 
 2 s(x0)  CRS   s(x0)   F1    F2    -0.635 
 3 s(x0)  CRS   s(x0)   F1    F3     0.265 
 4 s(x0)  CRS   s(x0)   F1    F4    -0.0203
 5 s(x0)  CRS   s(x0)   F1    F5     0.0441
 6 s(x0)  CRS   s(x0)   F1    F6     0.0378
 7 s(x0)  CRS   s(x0)   F1    F7     0.0482
 8 s(x0)  CRS   s(x0)   F1    F8     0.0216
 9 s(x0)  CRS   s(x0)   F1    F9     0.0247
10 s(x0)  CRS   s(x0)   F2    F1    -0.635 
# i 395 more rows
> 
> # for a specific smooth
> penalty(m, smooth = "s(x2):fac1")
# A tibble: 81 x 6
   smooth     type  penalty    row   col     value
   <chr>      <chr> <chr>      <chr> <chr>   <dbl>
 1 s(x2):fac1 CRS   s(x2):fac1 F1    F1     1.66  
 2 s(x2):fac1 CRS   s(x2):fac1 F1    F2    -0.755 
 3 s(x2):fac1 CRS   s(x2):fac1 F1    F3     0.430 
 4 s(x2):fac1 CRS   s(x2):fac1 F1    F4     0.0846
 5 s(x2):fac1 CRS   s(x2):fac1 F1    F5     0.192 
 6 s(x2):fac1 CRS   s(x2):fac1 F1    F6     0.152 
 7 s(x2):fac1 CRS   s(x2):fac1 F1    F7     0.188 
 8 s(x2):fac1 CRS   s(x2):fac1 F1    F8     0.164 
 9 s(x2):fac1 CRS   s(x2):fac1 F1    F9     0.0597
10 s(x2):fac1 CRS   s(x2):fac1 F2    F1    -0.755 
# i 71 more rows
> 
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("predicted_samples")
> ### * predicted_samples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predicted_samples
> ### Title: Draw new response values from the conditional distribution of
> ###   the response
> ### Aliases: predicted_samples predicted_samples.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 1000, dist = "normal", scale = 2, seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> predicted_samples(m, n = 5, seed = 42)
# A tibble: 5,000 x 3
    .row .draw .response
   <int> <int>     <dbl>
 1     1     1      8.93
 2     2     1      4.23
 3     3     1      7.71
 4     4     1      8.51
 5     5     1     10.1 
 6     6     1      8.20
 7     7     1      8.95
 8     8     1      7.20
 9     9     1     18.1 
10    10     1     12.7 
# i 4,990 more rows
> 
> ## Can pass arguments to predict.gam()
> ## Don't show: 
> set.seed(6791)
> ## End(Don't show)
> newd <- data.frame(x0 = runif(10), x1 = runif(10), x2 = runif(10),
+                    x3 = runif(10))
> 
> ## Exclude s(x2)
> predicted_samples(m, n = 5, newd, exclude = "s(x2)", seed = 25)
# A tibble: 50 x 3
    .row .draw .response
   <int> <int>     <dbl>
 1     1     1      9.42
 2     2     1      6.97
 3     3     1      8.10
 4     4     1      9.95
 5     5     1      6.75
 6     6     1     10.3 
 7     7     1     10.8 
 8     8     1     10.5 
 9     9     1      8.43
10    10     1     12.2 
# i 40 more rows
> 
> ## Exclude s(x1)
> predicted_samples(m, n = 5, newd, exclude = "s(x1)", seed = 25)
# A tibble: 50 x 3
    .row .draw .response
   <int> <int>     <dbl>
 1     1     1      6.05
 2     2     1      5.28
 3     3     1      5.96
 4     4     1     13.7 
 5     5     1      4.36
 6     6     1      5.11
 7     7     1     12.5 
 8     8     1      5.66
 9     9     1     12.6 
10    10     1      8.38
# i 40 more rows
> 
> ## Select which terms --- result should be the same as previous
> ## but note that we have to include any parametric terms, including the
> ## constant term
> predicted_samples(m, n = 5, newd, seed = 25,
+                   terms = c("Intercept", "s(x0)", "s(x2)", "s(x3)"))
# A tibble: 50 x 3
    .row .draw .response
   <int> <int>     <dbl>
 1     1     1    -1.94 
 2     2     1    -2.71 
 3     3     1    -2.03 
 4     4     1     5.73 
 5     5     1    -3.63 
 6     6     1    -2.87 
 7     7     1     4.48 
 8     8     1    -2.33 
 9     9     1     4.65 
10    10     1     0.395
# i 40 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("qq_plot")
> ### * qq_plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: qq_plot
> ### Title: Quantile-quantile plot of model residuals
> ### Aliases: qq_plot qq_plot.default qq_plot.gam qq_plot.glm qq_plot.lm
> 
> ### ** Examples
> 
> load_mgcv()
> ## simulate binomial data...
> dat <- data_sim("eg1", n = 200, dist = "binary", scale = .33, seed = 0)
> p <- binomial()$linkinv(dat$f)               # binomial p
> n <- sample(c(1, 3), 200, replace = TRUE) # binomial n
> dat <- transform(dat, y = rbinom(n, n, p), n = n)
> m <- gam( y / n ~ s(x0) + s(x1) + s(x2) + s(x3),
+          family = binomial, data = dat, weights = n,
+          method = "REML")
> 
> ## Q-Q plot; default using direct randomization of uniform quantiles
> qq_plot(m)
> 
> ## Alternatively use simulate new data from the model, which
> ## allows construction of reference intervals for the Q-Q plot
> qq_plot(m, method = "simulate", point_col = "steelblue",
+         point_alpha = 0.4)
> 
> ## ... or use the usual normality assumption
> qq_plot(m, method = "normal")
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("ref_level")
> ### * ref_level
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ref_level
> ### Title: Return the reference or specific level of a factor
> ### Aliases: ref_level level
> 
> ### ** Examples
> 
> ## Don't show: 
> set.seed(1)
> ## End(Don't show)
> f <- factor(sample(letters[1:5], 100, replace = TRUE))
> 
> # the reference level
> ref_level(f)
[1] a
Levels: a b c d e
> 
> # a specific level
> level(f, level = "b")
[1] b
Levels: a b c d e
> 
> # note that the levels will always match the input factor
> identical(levels(f), levels(ref_level(f)))
[1] TRUE
> identical(levels(f), levels(level(f, "c")))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("response_derivatives")
> ### * response_derivatives
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: response_derivatives
> ### Title: Derivatives on the response scale from an estimated GAM
> ### Aliases: response_derivatives response_derivatives.default
> ###   response_derivatives.gamm response_derivatives.gam
> 
> ### ** Examples
> 
> 
> library("ggplot2")
> library("patchwork")
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", dist = "negbin", scale = 0.25, seed = 42)
> 
> # fit the GAM (note: for execution time reasons using bam())
> m <- bam(y ~ s(x0) + s(x1) + s(x2) + s(x3),
+     data = df, family = nb(), method = "fREML", discrete = TRUE)
> 
> # data slice through data along x2 - all other covariates will be set to
> # typical values (value closest to median)
> ds <- data_slice(m, x2 = evenly(x2, n = 100))
> 
> # fitted values along x2
> fv <- fitted_values(m, smooth = "s(x2)", data = ds)
> 
> # response derivatives - ideally n_sim = >10000
> y_d <- response_derivatives(m, data = ds, type = "central", focal = "x2",
+     eps = 0.01, seed = 21, n_sim = 1000)
> 
> # draw fitted values along x2
> p1 <- fv |>
+     ggplot(aes(x = x2, y = .fitted)) +
+     geom_ribbon(aes(ymin = .lower_ci, ymax = .upper_ci, y = NULL),
+         alpha = 0.2) +
+     geom_line() +
+     labs(title = "Estimated count as a function of x2",
+          y = "Estimated count")
> 
> # draw response derivatives
> p2 <- y_d |>
+     ggplot(aes(x = x2, y = .derivative)) +
+     geom_ribbon(aes(ymin = .lower_ci, ymax = .upper_ci), alpha = 0.2) +
+     geom_line() +
+     labs(title = "Estimated 1st derivative of estimated count",
+          y = "First derivative")
> 
> # draw both panels
> p1 + p2 + plot_layout(nrow = 2)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’, ‘package:patchwork’, ‘package:ggplot2’

> nameEx("rootogram")
> ### * rootogram
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rootogram
> ### Title: Rootograms to assess goodness of model fit
> ### Aliases: rootogram rootogram.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 6)
> ## End(Don't show)
> df <- data_sim("eg1", n = 1000, dist = "poisson", scale = 0.1, seed = 6)
> 
> # A poisson example
> m <- gam(y ~ s(x0, bs = "cr") + s(x1, bs = "cr") + s(x2, bs = "cr") +
+          s(x3, bs = "cr"), family = poisson(), data = df, method = "REML")
> rg <- rootogram(m)
> rg
# A tibble: 21 x 3
     bin observed    fitted
   <dbl>    <int>     <dbl>
 1     0      113 116.640  
 2     1      236 227.869  
 3     2      230 239.168  
 4     3      200 181.679  
 5     4       94 113.432  
 6     5       68  62.4881 
 7     6       27  31.6795 
 8     7       22  15.1323 
 9     8        4   6.88637
10     9        3   2.99628
# i 11 more rows
> draw(rg) # plot the rootogram
> 
> # A Gaussian example
> df <- data_sim("eg1", dist = "normal", seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> draw(rootogram(m, breaks = "FD"), type = "suspended")
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("simulate")
> ### * simulate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate.gam
> ### Title: Simulate from the posterior distribution of a GAM
> ### Aliases: simulate.gam simulate.gamm simulate.scam
> 
> ### ** Examples
> 
> load_mgcv()
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> sims <- simulate(m1, nsim = 5, seed = 42)
> head(sims)
          [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 11.445470 11.374304 10.098681  7.264881  8.796630
[2,]  6.510912  5.909584  9.057362  7.698084 11.444781
[3,]  3.837995  3.230610  3.550240  3.759380  4.774581
[4,] 12.361830 11.209226 10.714215 11.861957 10.746417
[5,] 14.851461 12.911440 11.356984 15.783913 15.106270
[6,]  5.921276  4.158963  5.520856  7.973614  9.654888
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("smooth_coefs")
> ### * smooth_coefs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smooth_coefs
> ### Title: Coefficients for a particular smooth
> ### Aliases: smooth_coefs smooth_coefs.gam smooth_coefs.bam
> ###   smooth_coefs.gamm smooth_coefs.gamm4 smooth_coefs.list
> ###   smooth_coefs.mgcv.smooth smooth_coefs.scam
> 
> ### ** Examples
> 
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> load_mgcv()
> df <- data_sim("eg1", seed = 2)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> ## IGNORE_RDIFF_BEGIN
> smooth_coefs(m, term = "s(x2)")
  s(x2).1   s(x2).2   s(x2).3   s(x2).4   s(x2).5   s(x2).6   s(x2).7   s(x2).8 
-6.533373  9.694277  2.194078  1.967280 -2.374874  1.207638 -1.572586  9.269744 
  s(x2).9 
 5.622738 
> ## IGNORE_RDIFF_END
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("smooth_data")
> ### * smooth_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smooth_data
> ### Title: Generate regular data over the covariates of a smooth
> ### Aliases: smooth_data
> 
> ### ** Examples
> 
> 
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 4)
> ## End(Don't show)
> load_mgcv()
> df <- data_sim("eg1", seed = 42)
> m <- bam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df)
> 
> # generate data over range of x1 for smooth s(x1)
> smooth_data(m, id = 2)
# A tibble: 100 x 1
          x1
       <dbl>
 1 0.0004050
 2 0.01046  
 3 0.02052  
 4 0.03057  
 5 0.04063  
 6 0.05069  
 7 0.06074  
 8 0.07080  
 9 0.08086  
10 0.09091  
# i 90 more rows
> 
> # generate data over range of x1 for smooth s(x1), with typical value for
> # other covariates in the model
> smooth_data(m, id = 2, include_all = TRUE)
# A tibble: 100 x 4
          x1     x0     x2     x3
       <dbl>  <dbl>  <dbl>  <dbl>
 1 0.0004050 0.4883 0.4708 0.4879
 2 0.01046   0.4883 0.4708 0.4879
 3 0.02052   0.4883 0.4708 0.4879
 4 0.03057   0.4883 0.4708 0.4879
 5 0.04063   0.4883 0.4708 0.4879
 6 0.05069   0.4883 0.4708 0.4879
 7 0.06074   0.4883 0.4708 0.4879
 8 0.07080   0.4883 0.4708 0.4879
 9 0.08086   0.4883 0.4708 0.4879
10 0.09091   0.4883 0.4708 0.4879
# i 90 more rows
> 
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("smooth_estimates")
> ### * smooth_estimates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smooth_estimates
> ### Title: Evaluate smooths at covariate values
> ### Aliases: smooth_estimates smooth_estimates.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 6)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 400, dist = "normal", scale = 2, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> ## evaluate all smooths
> smooth_estimates(m1)
# A tibble: 400 x 9
   smooth type  by    .estimate      .se         x0    x1    x2    x3
   <chr>  <chr> <chr>     <dbl>    <dbl>      <dbl> <dbl> <dbl> <dbl>
 1 s(x0)  TPRS  <NA>  -0.966542 0.316118 0.00710904    NA    NA    NA
 2 s(x0)  TPRS  <NA>  -0.925391 0.297170 0.0171157     NA    NA    NA
 3 s(x0)  TPRS  <NA>  -0.884233 0.279256 0.0271224     NA    NA    NA
 4 s(x0)  TPRS  <NA>  -0.843050 0.262594 0.0371291     NA    NA    NA
 5 s(x0)  TPRS  <NA>  -0.801824 0.247376 0.0471358     NA    NA    NA
 6 s(x0)  TPRS  <NA>  -0.760536 0.233728 0.0571425     NA    NA    NA
 7 s(x0)  TPRS  <NA>  -0.719175 0.221701 0.0671492     NA    NA    NA
 8 s(x0)  TPRS  <NA>  -0.677736 0.211261 0.0771559     NA    NA    NA
 9 s(x0)  TPRS  <NA>  -0.636220 0.202303 0.0871626     NA    NA    NA
10 s(x0)  TPRS  <NA>  -0.594641 0.194685 0.0971693     NA    NA    NA
# i 390 more rows
> 
> ## or selected smooths
> smooth_estimates(m1, smooth = c("s(x0)", "s(x1)"))
# A tibble: 200 x 7
   smooth type  by    .estimate      .se         x0    x1
   <chr>  <chr> <chr>     <dbl>    <dbl>      <dbl> <dbl>
 1 s(x0)  TPRS  <NA>  -0.966542 0.316118 0.00710904    NA
 2 s(x0)  TPRS  <NA>  -0.925391 0.297170 0.0171157     NA
 3 s(x0)  TPRS  <NA>  -0.884233 0.279256 0.0271224     NA
 4 s(x0)  TPRS  <NA>  -0.843050 0.262594 0.0371291     NA
 5 s(x0)  TPRS  <NA>  -0.801824 0.247376 0.0471358     NA
 6 s(x0)  TPRS  <NA>  -0.760536 0.233728 0.0571425     NA
 7 s(x0)  TPRS  <NA>  -0.719175 0.221701 0.0671492     NA
 8 s(x0)  TPRS  <NA>  -0.677736 0.211261 0.0771559     NA
 9 s(x0)  TPRS  <NA>  -0.636220 0.202303 0.0871626     NA
10 s(x0)  TPRS  <NA>  -0.594641 0.194685 0.0971693     NA
# i 190 more rows
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("smooth_samples")
> ### * smooth_samples
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: smooth_samples
> ### Title: Posterior draws for individual smooths
> ### Aliases: smooth_samples smooth_samples.gam
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(cli.unicode = FALSE, pillar.sigfig = 3)
> ## End(Don't show)
> dat <- data_sim("eg1", n = 400, seed = 2)
> m1 <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = dat, method = "REML")
> 
> sms <- smooth_samples(m1, term = "s(x0)", n = 5, seed = 42)
> 
> ## A factor by example (with a spurious covariate x0)
> dat <- data_sim("eg4", n = 1000, seed = 2)
> 
> ## fit model...
> m2 <- gam(y ~ fac + s(x2, by = fac) + s(x0), data = dat)
> sms <- smooth_samples(m2, n = 5, seed = 42)
> draw(sms)
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("theta")
> ### * theta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: theta
> ### Title: General extractor for additional parameters in mgcv models
> ### Aliases: theta theta.gam
> 
> ### ** Examples
> 
> load_mgcv()
> df <- data_sim("eg1", dist = "poisson", seed = 42, scale = 1/5)
> m <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML",
+          family = nb())
> p <- theta(m)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("tidy_basis")
> ### * tidy_basis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tidy_basis
> ### Title: A tidy basis representation of a smooth object
> ### Aliases: tidy_basis
> 
> ### ** Examples
> 
> load_mgcv()
> ## Don't show: 
> op <- options(pillar.sigfig = 3, cli.unicode = FALSE)
> ## End(Don't show)
> df <- data_sim("eg1", n = 400, seed = 42)
> 
> # fit model
> m  <- gam(y ~ s(x0) + s(x1) + s(x2) + s(x3), data = df, method = "REML")
> 
> # tidy representaition of a basis for a smooth definition
> # extract the smooth
> sm <- get_smooth(m, "s(x2)")
> # get the tidy basis - need to pass where we want it to be evaluated
> bf <- tidy_basis(sm, at = df)
> 
> # can weight the basis by the model coefficients for this smooth
> bf <- tidy_basis(sm, at = df, coefs = smooth_coefs(sm, model = m))
> ## Don't show: 
> options(op)
> ## End(Don't show)
> 
> 
> 
> cleanEx()

detaching ‘package:mgcv’

> nameEx("vars_from_label")
> ### * vars_from_label
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vars_from_label
> ### Title: Returns names of variables from a smooth label
> ### Aliases: vars_from_label
> 
> ### ** Examples
> 
> 
> vars_from_label("s(x1)")
[1] "x1"
> vars_from_label("t2(x1,x2,x3)")
[1] "x1" "x2" "x3"
> 
> 
> 
> cleanEx()
> nameEx("worm_plot")
> ### * worm_plot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: worm_plot
> ### Title: Worm plot of model residuals
> ### Aliases: worm_plot worm_plot.gam worm_plot.glm worm_plot.lm
> 
> ### ** Examples
> 
> load_mgcv()
> ## simulate binomial data...
> dat <- data_sim("eg1", n = 200, dist = "binary", scale = .33, seed = 0)
> p <- binomial()$linkinv(dat$f)               # binomial p
> n <- sample(c(1, 3), 200, replace = TRUE) # binomial n
> dat <- transform(dat, y = rbinom(n, n, p), n = n)
> m <- gam( y / n ~ s(x0) + s(x1) + s(x2) + s(x3),
+          family = binomial, data = dat, weights = n,
+          method = "REML")
> 
> ## Worm plot; default using direct randomization of uniform quantiles
> ## Note no reference bands are drawn with this method.
> worm_plot(m)
> 
> ## Alternatively use simulate new data from the model, which
> ## allows construction of reference intervals for the Q-Q plot
> worm_plot(m, method = "simulate", point_col = "steelblue",
+           point_alpha = 0.4)
> 
> ## ... or use the usual normality assumption
> worm_plot(m, method = "normal")
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:mgcv’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  36.697 0.348 36.368 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
